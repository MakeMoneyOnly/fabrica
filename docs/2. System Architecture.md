# Fabrica - System Architecture Document

**Version:** 1.0  
**Last Updated:** November 19, 2025  
**Target Environment:** Production (Ethiopian Market)

---

## 1. Architecture Overview

### High-Level Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        CLIENT LAYER                              │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │   Creator    │  │   Customer   │  │    Admin     │         │
│  │  Dashboard   │  │  Storefront  │  │    Panel     │         │
│  │  (Next.js)   │  │  (Next.js)   │  │  (Next.js)   │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
│         │                  │                  │                  │
│         └──────────────────┴──────────────────┘                 │
│                            │                                     │
└────────────────────────────┼─────────────────────────────────────┘
                             │
                    ┌────────▼────────┐
                    │   CDN LAYER     │
                    │  (Cloudflare)   │
                    └────────┬────────┘
                             │
┌────────────────────────────┼─────────────────────────────────────┐
│                     API GATEWAY                                   │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────┐           │
│  │         Next.js API Routes / Edge Functions      │           │
│  │  (Authentication, Rate Limiting, Request Routing)│           │
│  └──────────────────────────────────────────────────┘           │
└────────────────────────────┬─────────────────────────────────────┘
                             │
        ┌────────────────────┼────────────────────┐
        │                    │                    │
┌───────▼──────┐    ┌───────▼──────┐    ┌───────▼──────┐
│   SUPABASE   │    │    CLERK     │    │     CHAPA    │
│   Backend    │    │     Auth     │    │   Payment    │
├──────────────┤    ├──────────────┤    ├──────────────┤
│ • PostgreSQL │    │ • JWT Tokens │    │ • Webhooks   │
│ • Storage    │    │ • OAuth      │    │ • API v2     │
│ • Edge Funcs │    │ • Sessions   │    │ • Refunds    │
└──────────────┘    └──────────────┘    └──────────────┘
        │
┌───────▼──────────────────────────────────┐
│        THIRD-PARTY SERVICES              │
├──────────────────────────────────────────┤
│ • Resend (Email Delivery)                │
│ • Google Calendar API (Bookings)         │
│ • Cloudflare R2 (File Storage Backup)    │
│ • Sentry (Error Tracking)                │
│ • PostHog (Analytics)                    │
└──────────────────────────────────────────┘
```

---

## 2. Architecture Principles

### 2.1 Design Principles

1. **Mobile-First:** All features designed for mobile before desktop
2. **Edge-First:** Leverage edge computing for Ethiopian users (reduced latency)
3. **Progressive Enhancement:** Core functionality works without JavaScript
4. **Offline-First:** Service Workers for offline product browsing
5. **Fail-Safe:** Graceful degradation when third-party services fail
6. **Zero-Trust Security:** Every request authenticated and authorized
7. **Cost-Optimized:** Use free tiers and pay-as-you-grow services

### 2.2 Scalability Strategy

- **Horizontal Scaling:** Stateless API design allows unlimited scaling
- **Database Scaling:** Supabase handles scaling automatically (connection pooling)
- **CDN Caching:** 90%+ of requests served from edge (storefront pages, images)
- **Background Jobs:** Async processing for emails, analytics aggregation
- **Read Replicas:** Separate read/write databases for analytics queries (Phase 2)

### 2.3 Resilience Patterns

- **Circuit Breaker:** Fail fast when Chapa API is down (multiple payment methods available)
- **Retry with Backoff:** Automatic retries for transient failures
- **Rate Limiting:** Protect against DDoS and abuse
- **Idempotency:** Prevent duplicate payments/orders
- **Health Checks:** Automated monitoring and alerting

---

## 3. Frontend Architecture

### 3.1 Technology Stack

- **Framework:** Next.js 14+ (App Router)
- **Language:** TypeScript 5+
- **Styling:** Tailwind CSS 3+
- **State Management:** Zustand (lightweight, 1KB)
- **Data Fetching:** React Query (TanStack Query)
- **Forms:** React Hook Form + Zod validation
- **UI Components:** shadcn/ui (customizable, accessible)
- **Icons:** Lucide React (tree-shakeable)
- **Date/Time:** date-fns (smaller than moment.js)

### 3.2 Application Structure

```
fabrica-web/
├── app/                          # Next.js 14 App Router
│   ├── (auth)/                   # Auth-protected routes
│   │   ├── dashboard/            # Creator dashboard
│   │   │   ├── page.tsx          # Overview
│   │   │   ├── products/         # Product management
│   │   │   ├── orders/           # Order history
│   │   │   ├── analytics/        # Analytics dashboard
│   │   │   ├── calendar/         # Booking calendar
│   │   │   ├── settings/         # Account settings
│   │   │   └── referrals/        # Referral dashboard
│   │   └── admin/                # Admin panel
│   │       ├── creators/         # Creator management
│   │       ├── moderation/       # Content moderation
│   │       ├── payouts/          # Payout management
│   │       ├── analytics/        # Platform analytics
│   │       └── support/          # Support tickets
│   ├── (public)/                 # Public routes
│   │   ├── [username]/           # Dynamic storefront
│   │   │   └── page.tsx          # Creator storefront
│   │   ├── checkout/             # Checkout flow
│   │   ├── order-confirmation/   # Post-purchase page
│   │   └── download/[id]/        # Secure download
│   ├── (marketing)/              # Marketing pages
│   │   ├── page.tsx              # Homepage
│   │   ├── pricing/              # Pricing page
│   │   ├── features/             # Features page
│   │   ├── about/                # About page
│   │   └── help/                 # Help center
│   ├── api/                      # API routes
│   │   ├── webhooks/             # Payment webhooks
│   │   │   ├── chapa/            # Chapa webhooks
│   │   │   └── chapa/            # Chapa webhooks
│   │   ├── payments/             # Payment initiation
│   │   ├── products/             # Product CRUD
│   │   ├── orders/               # Order management
│   │   ├── uploads/              # File upload handling
│   │   └── analytics/            # Analytics endpoints
│   ├── layout.tsx                # Root layout
│   └── globals.css               # Global styles
├── components/                   # Reusable components
│   ├── ui/                       # shadcn/ui components
│   ├── dashboard/                # Dashboard-specific
│   ├── storefront/               # Storefront-specific
│   ├── forms/                    # Form components
│   └── layouts/                  # Layout components
├── lib/                          # Utility functions
│   ├── supabase/                 # Supabase clients
│   │   ├── client.ts             # Browser client
│   │   ├── server.ts             # Server client
│   │   └── admin.ts              # Admin client
│   ├── clerk/                    # Clerk auth utilities
│   ├── payments/                 # Payment integrations
│   │   ├── chapa.ts               # Chapa SDK
│   │   └── chapa.ts              # Chapa SDK
│   ├── email/                    # Email templates
│   ├── analytics/                # Analytics tracking
│   └── utils/                    # Helper functions
├── hooks/                        # Custom React hooks
│   ├── useUser.ts                # Current user hook
│   ├── useProducts.ts            # Product data hook
│   ├── useOrders.ts              # Order data hook
│   └── useAnalytics.ts           # Analytics hook
├── types/                        # TypeScript types
│   ├── database.types.ts         # Supabase generated types
│   ├── api.types.ts              # API types
│   └── models.types.ts           # Domain models
├── config/                       # Configuration
│   ├── site.ts                   # Site metadata
│   ├── plans.ts                  # Subscription plans
│   └── constants.ts              # App constants
└── public/                       # Static assets
    ├── images/                   # Images
    └── icons/                    # Icons/favicons
```

### 3.3 Code Splitting Strategy

- **Route-based splitting:** Automatic in Next.js 14
- **Component-level splitting:** Lazy load heavy components
  ```typescript
  const AnalyticsChart = dynamic(() => import('./AnalyticsChart'), {
    loading: () => <ChartSkeleton />,
    ssr: false // Client-only for chart libraries
  });
  ```
- **Third-party libraries:** Load only when needed
  - Calendar components (only on booking pages)
  - Rich text editor (only on product creation)
  - Video player (only when video products)

### 3.4 Performance Optimizations

#### Image Optimization

```typescript
// Next.js Image component with automatic optimization
<Image
  src={product.coverImage}
  alt={product.title}
  width={800}
  height={600}
  quality={80}
  placeholder="blur"
  blurDataURL={product.blurHash}
  sizes="(max-width: 768px) 100vw, 50vw"
/>
```

#### Caching Strategy

- **Static Generation (SSG):** Marketing pages, help docs
- **Incremental Static Regeneration (ISR):** Creator storefronts (revalidate every 60s)
- **Server-Side Rendering (SSR):** Dashboard pages (always fresh data)
- **Client-Side Rendering (CSR):** Real-time analytics

#### Low-Bandwidth Mode

```typescript
// Detect slow connection and adapt
const connection = (navigator as any).connection
if (connection?.effectiveType === '2g' || connection?.effectiveType === 'slow-2g') {
  // Disable auto-playing videos
  // Load lower-quality images
  // Reduce polling frequency
}
```

---

## 4. Backend Architecture

### 4.1 Supabase Setup

#### Database (PostgreSQL 15)

**Core Tables:**

```sql
-- Users (synced from Clerk via webhook)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_user_id TEXT UNIQUE NOT NULL,
  email TEXT UNIQUE NOT NULL,
  phone TEXT,
  full_name TEXT,
  username TEXT UNIQUE,
  avatar_url TEXT,
  bio TEXT,
  social_links JSONB DEFAULT '{}',
  subscription_plan TEXT DEFAULT 'trial', -- trial, creator, creator_pro, inactive
  subscription_status TEXT DEFAULT 'active', -- active, past_due, canceled
  trial_ends_at TIMESTAMP,
  subscription_current_period_end TIMESTAMP,
  telebirr_account TEXT,
  telebirr_verified BOOLEAN DEFAULT FALSE,
  referral_code TEXT UNIQUE NOT NULL,
  referred_by UUID REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_clerk_id ON users(clerk_user_id);
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_referral_code ON users(referral_code);

-- Products
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  creator_id UUID REFERENCES users(id) ON DELETE CASCADE,
  type TEXT NOT NULL, -- digital, booking, link
  title TEXT NOT NULL,
  description TEXT,
  price DECIMAL(10,2), -- ETB, null for free products
  currency TEXT DEFAULT 'ETB',
  cover_image_url TEXT,
  status TEXT DEFAULT 'active', -- active, draft, archived

  -- Digital product specific
  file_url TEXT,
  file_size BIGINT,
  file_type TEXT,
  external_url TEXT,

  -- Booking specific
  duration_minutes INTEGER,
  booking_type TEXT, -- zoom, google_meet, phone, in_person
  calendar_settings JSONB,

  -- Analytics
  views_count INTEGER DEFAULT 0,
  sales_count INTEGER DEFAULT 0,
  revenue_total DECIMAL(10,2) DEFAULT 0,

  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_products_creator ON products(creator_id);
CREATE INDEX idx_products_status ON products(status);
CREATE INDEX idx_products_type ON products(type);

-- Orders
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_number TEXT UNIQUE NOT NULL, -- FAB-20250119-XXXX
  product_id UUID REFERENCES products(id),
  creator_id UUID REFERENCES users(id),

  -- Customer info
  customer_email TEXT NOT NULL,
  customer_name TEXT NOT NULL,
  customer_phone TEXT,

  -- Payment info
  amount DECIMAL(10,2) NOT NULL,
  currency TEXT DEFAULT 'ETB',
  payment_provider TEXT NOT NULL, -- chapa (primary), telebirr (via Chapa)
  payment_provider_id TEXT, -- Transaction ID from provider
  payment_status TEXT DEFAULT 'pending', -- pending, completed, failed, refunded

  -- Booking specific
  booking_datetime TIMESTAMP,
  booking_timezone TEXT DEFAULT 'Africa/Addis_Ababa',

  -- Metadata
  metadata JSONB DEFAULT '{}', -- Store additional data
  ip_address INET,
  user_agent TEXT,

  -- Timestamps
  paid_at TIMESTAMP,
  refunded_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_orders_creator ON orders(creator_id);
CREATE INDEX idx_orders_customer_email ON orders(customer_email);
CREATE INDEX idx_orders_payment_status ON orders(payment_status);
CREATE INDEX idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX idx_orders_order_number ON orders(order_number);

-- Download Links (time-limited signed URLs)
CREATE TABLE download_links (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  order_id UUID REFERENCES orders(id) ON DELETE CASCADE,
  product_id UUID REFERENCES products(id) ON DELETE CASCADE,
  token TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  download_count INTEGER DEFAULT 0,
  max_downloads INTEGER DEFAULT 3,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_download_links_token ON download_links(token);
CREATE INDEX idx_download_links_expires_at ON download_links(expires_at);

-- Referrals
CREATE TABLE referrals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  referrer_id UUID REFERENCES users(id) ON DELETE CASCADE,
  referred_user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'pending', -- pending, active, inactive
  commission_rate DECIMAL(5,2) DEFAULT 20.00, -- 20%
  total_earned DECIMAL(10,2) DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(referrer_id, referred_user_id)
);

CREATE INDEX idx_referrals_referrer ON referrals(referrer_id);
CREATE INDEX idx_referrals_referred ON referrals(referred_user_id);

-- Referral Commissions (monthly payouts)
CREATE TABLE referral_commissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  referral_id UUID REFERENCES referrals(id) ON DELETE CASCADE,
  amount DECIMAL(10,2) NOT NULL,
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  status TEXT DEFAULT 'pending', -- pending, paid, failed
  paid_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_commissions_referral ON referral_commissions(referral_id);
CREATE INDEX idx_commissions_status ON referral_commissions(status);

-- Analytics Events (for tracking)
CREATE TABLE analytics_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  event_type TEXT NOT NULL, -- page_view, product_view, checkout_started, purchase, etc.
  event_data JSONB DEFAULT '{}',
  session_id TEXT,
  ip_address INET,
  user_agent TEXT,
  referrer TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_analytics_user ON analytics_events(user_id);
CREATE INDEX idx_analytics_type ON analytics_events(event_type);
CREATE INDEX idx_analytics_created_at ON analytics_events(created_at DESC);

-- Storefront Customization
CREATE TABLE storefront_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE REFERENCES users(id) ON DELETE CASCADE,
  theme_name TEXT DEFAULT 'modern',
  primary_color TEXT DEFAULT '#000000',
  custom_css TEXT,
  show_fabrica_badge BOOLEAN DEFAULT TRUE,
  domain_forwarding TEXT,
  seo_title TEXT,
  seo_description TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Admin Moderation
CREATE TABLE moderation_flags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flagged_by UUID REFERENCES users(id),
  target_type TEXT NOT NULL, -- user, product
  target_id UUID NOT NULL,
  reason TEXT NOT NULL,
  status TEXT DEFAULT 'pending', -- pending, reviewed, actioned
  admin_notes TEXT,
  actioned_by UUID REFERENCES users(id),
  actioned_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_moderation_status ON moderation_flags(status);
CREATE INDEX idx_moderation_target ON moderation_flags(target_type, target_id);
```

#### Row Level Security (RLS) Policies

```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
-- ... (repeat for all tables)

-- Users: Can only read/update their own data
CREATE POLICY "Users can view own profile"
  ON users FOR SELECT
  USING (clerk_user_id = auth.jwt() ->> 'sub');

CREATE POLICY "Users can update own profile"
  ON users FOR UPDATE
  USING (clerk_user_id = auth.jwt() ->> 'sub');

-- Products: Creators manage their own, public can view active
CREATE POLICY "Creators can manage own products"
  ON products FOR ALL
  USING (creator_id = (SELECT id FROM users WHERE clerk_user_id = auth.jwt() ->> 'sub'));

CREATE POLICY "Public can view active products"
  ON products FOR SELECT
  USING (status = 'active');

-- Orders: Creators can view their orders
CREATE POLICY "Creators can view own orders"
  ON orders FOR SELECT
  USING (creator_id = (SELECT id FROM users WHERE clerk_user_id = auth.jwt() ->> 'sub'));

-- Admin policies (superuser role)
CREATE POLICY "Admins have full access"
  ON users FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE clerk_user_id = auth.jwt() ->> 'sub'
      AND email IN ('admin@fabrica.et', 'your-email@example.com')
    )
  );
```

---

### 4.2 Supabase Storage

**Buckets:**

- `product-files`: Digital products (max 500MB per file)
- `cover-images`: Product cover images
- `avatars`: User profile pictures
- `temp-uploads`: Temporary uploads (auto-delete after 24h)

**Storage Policies:**

```sql
-- Product files: Only accessible via signed URLs
CREATE POLICY "Product files require signed URL"
  ON storage.objects FOR SELECT
  IN BUCKET 'product-files'
  USING (false); -- No direct access

-- Cover images: Public read, creator write
CREATE POLICY "Public can view cover images"
  ON storage.objects FOR SELECT
  IN BUCKET 'cover-images'
  USING (true);

CREATE POLICY "Creators can upload cover images"
  ON storage.objects FOR INSERT
  IN BUCKET 'cover-images'
  WITH CHECK (
    auth.uid() = (storage.foldername(name))[1]::uuid
  );
```

---

### 4.3 Edge Functions (Supabase)

**Use Cases:**

1. **Payment Webhook Handler:**
   - Verify Chapa webhook signatures
   - Update order status
   - Trigger email notifications
   - Generate download links

2. **Scheduled Payout Processing:**
   - Run monthly on 15th
   - Calculate referral commissions
   - Initiate Chapa payouts

3. **Analytics Aggregation:**
   - Hourly aggregation of analytics events
   - Update product view/sales counts
   - Cache dashboard metrics

4. **File Upload Processing:**
   - Generate thumbnails for images
   - Extract video metadata
   - Scan for malware

**Example: Payment Webhook Handler**

```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from '@supabase/supabase-js'

serve(async (req) => {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  )

  // Verify webhook signature
  const signature = req.headers.get('Chapa-Signature')
  const body = await req.json()

  if (!verifySignature(signature, body)) {
    return new Response('Invalid signature', { status: 401 })
  }

  // Update order status
  const { data: order, error } = await supabase
    .from('orders')
    .update({
      payment_status: 'completed',
      paid_at: new Date().toISOString(),
      payment_provider_id: body.transaction_id,
    })
    .eq('id', body.order_id)
    .select()
    .single()

  if (error) {
    return new Response(JSON.stringify({ error }), { status: 500 })
  }

  // Generate download link for digital products
  if (order.product.type === 'digital') {
    await generateDownloadLink(order.id)
  }

  // Send confirmation email
  await sendOrderConfirmationEmail(order)

  return new Response(JSON.stringify({ success: true }))
})
```

---

## 5. Authentication & Authorization

### 5.1 Clerk Integration

**Setup:**

```typescript
// app/layout.tsx
import { ClerkProvider } from '@clerk/nextjs'

export default function RootLayout({ children }) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body>{children}</body>
      </html>
    </ClerkProvider>
  )
}
```

**Auth Flow:**

1. User signs up via Clerk
2. Clerk webhook fires on user creation
3. Next.js API route `/api/webhooks/clerk` receives webhook
4. Creates corresponding user record in Supabase
5. Generates unique referral code
6. Sends welcome email

**Webhook Handler:**

```typescript
// app/api/webhooks/clerk/route.ts
import { Webhook } from 'svix'
import { headers } from 'next/headers'
import { createClient } from '@/lib/supabase/admin'

export async function POST(req: Request) {
  const WEBHOOK_SECRET = process.env.CLERK_WEBHOOK_SECRET!
  const headerPayload = headers()
  const svix_id = headerPayload.get('svix-id')
  const svix_timestamp = headerPayload.get('svix-timestamp')
  const svix_signature = headerPayload.get('svix-signature')

  const payload = await req.json()
  const body = JSON.stringify(payload)

  const wh = new Webhook(WEBHOOK_SECRET)
  let evt

  try {
    evt = wh.verify(body, {
      'svix-id': svix_id!,
      'svix-timestamp': svix_timestamp!,
      'svix-signature': svix_signature!,
    })
  } catch (err) {
    return new Response('Webhook verification failed', { status: 400 })
  }

  const supabase = createClient()

  if (evt.type === 'user.created') {
    const { id, email_addresses, phone_numbers, first_name, last_name } = evt.data

    // Generate unique username from email
    const username = await generateUniqueUsername(email_addresses[0].email_address)

    // Create user in Supabase
    const { error } = await supabase.from('users').insert({
      clerk_user_id: id,
      email: email_addresses[0].email_address,
      phone: phone_numbers[0]?.phone_number,
      full_name: `${first_name} ${last_name}`,
      username,
      referral_code: generateReferralCode(),
      subscription_plan: 'trial',
      trial_ends_at: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 days
    })

    if (error) {
      console.error('Failed to create user:', error)
      return new Response('Internal error', { status: 500 })
    }
  }

  return new Response('Webhook processed', { status: 200 })
}
```

### 5.2 Authorization Levels

**Roles:**

1. **Public:** Can view storefronts, make purchases (no auth required)
2. **Creator (Trial):** Limited features, 14-day access
3. **Creator (Paid):** Full creator features
4. **Creator Pro (Paid):** Advanced features (discount codes, affiliate share)
5. **Admin:** Platform management
6. **Super Admin:** Full system access

**Middleware for Route Protection:**

```typescript
// middleware.ts
import { authMiddleware } from '@clerk/nextjs'

export default authMiddleware({
  publicRoutes: [
    '/',
    '/pricing',
    '/features',
    '/help',
    '/:username', // Creator storefronts
    '/checkout',
    '/api/webhooks/(.*)',
  ],
  ignoredRoutes: ['/api/public/(.*)'],
})

export const config = {
  matcher: ['/((?!.+\\.[\\w]+$|_next).*)', '/', '/(api|trpc)(.*)'],
}
```

---

## 6. Payment Architecture

### 6.1 Chapa Payment Integration

**Payment Flow:**

```
1. Customer clicks "Buy Now"
   │
   ├─> Frontend: Open checkout modal
   │
2. Customer enters info (name, email, phone)
   │
   ├─> Frontend: Submit to /api/payments/initiate
   │
3. Backend: Create pending order in database
   │
   ├─> Call Chapa API to generate payment URL
   │
4. Backend: Return payment URL to frontend
   │
   ├─> Frontend: Redirect to Chapa checkout page
   │
5. Customer completes payment on Chapa
   │
   ├─> Chapa sends webhook to /api/webhooks/chapa
   │
6. Backend: Verify webhook signature
   │
   ├─> Update order status to "completed"
   ├─> Generate download link (if digital product)
   ├─> Send confirmation email
   │
7. Chapa redirects back to fabrica.et/order-confirmation/[orderId]
   │
   └─> Customer sees confirmation page with download link
```

**API Implementation:**

```typescript
// app/api/payments/initiate/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getChapaClient } from '@/lib/payments/chapa'

export async function POST(req: NextRequest) {
  const { productId, customerEmail, customerName, customerPhone } = await req.json()

  const supabase = createClient()

  // Fetch product details
  const { data: product } = await supabase
    .from('products')
    .select('*, creator:users!creator_id(*)')
    .eq('id', productId)
    .single()

  if (!product) {
    return NextResponse.json({ error: 'Product not found' }, { status: 404 })
  }

  // Create pending order
  const orderNumber = generateOrderNumber()
  const { data: order, error } = await supabase
    .from('orders')
    .insert({
      order_number: orderNumber,
      product_id: productId,
      creator_id: product.creator_id,
      customer_email: customerEmail,
      customer_name: customerName,
      customer_phone: customerPhone,
      amount: product.price,
      currency: 'ETB',
      payment_provider: 'chapa',
      payment_status: 'pending',
    })
    .select()
    .single()

  if (error) {
    return NextResponse.json({ error: 'Failed to create order' }, { status: 500 })
  }

  // Initiate Chapa payment
  const chapaClient = getChapaClient()
  const paymentResult = await chapaClient.initiatePayment({
    orderId: order.id,
    amount: product.price,
    customerName,
    customerPhone,
    returnUrl: `${process.env.NEXT_PUBLIC_APP_URL}/order-confirmation/${order.id}`,
    notifyUrl: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/chapa`,
  })

  if (!paymentResult.success) {
    return NextResponse.json({ error: 'Payment initiation failed' }, { status: 500 })
  }

  return NextResponse.json({
    orderId: order.id,
    paymentUrl: paymentResult.paymentUrl,
  })
}
```

### 6.2 Refund Processing

**Refund Flow:**

```typescript
// app/api/orders/[orderId]/refund/route.ts
import { createClient } from '@/lib/supabase/server'
import { getChapaClient } from '@/lib/payments/chapa'
import { auth } from '@clerk/nextjs'

export async function POST(req: Request, { params }: { params: { orderId: string } }) {
  const { userId } = auth()
  if (!userId) {
    return new Response('Unauthorized', { status: 401 })
  }

  const supabase = createClient()

  // Verify order belongs to this creator
  const { data: order } = await supabase
    .from('orders')
    .select('*, creator:users!creator_id(clerk_user_id)')
    .eq('id', params.orderId)
    .single()

  if (order.creator.clerk_user_id !== userId) {
    return new Response('Forbidden', { status: 403 })
  }

  if (order.payment_status === 'refunded') {
    return new Response('Already refunded', { status: 400 })
  }

  // Process refund with Chapa
  const refundResult = await processRefund({
    transactionId: order.payment_provider_id,
    amount: order.amount,
    reason: 'Creator-initiated refund',
  })

  if (!refundResult.success) {
    return new Response('Refund failed', { status: 500 })
  }

  // Update order status
  await supabase
    .from('orders')
    .update({
      payment_status: 'refunded',
      refunded_at: new Date().toISOString(),
    })
    .eq('id', params.orderId)

  // Revoke download links
  if (order.product.type === 'digital') {
    await supabase
      .from('download_links')
      .update({ expires_at: new Date().toISOString() })
      .eq('order_id', params.orderId)
  }

  // Send refund confirmation email
  await sendRefundConfirmationEmail(order)

  return new Response(JSON.stringify({ success: true }))
}
```

---

## 7. File Storage & CDN

### 7.1 Storage Strategy

**Primary Storage: Supabase Storage**

- Product files up to 500MB
- Automatic CDN distribution
- Signed URLs for secure access

**Backup Storage: Cloudflare R2** (Optional, Phase 2)

- For files >500MB
- Lower cost for high-volume storage
- Fallback if Supabase has issues

### 7.2 File Upload Flow

```typescript
// app/api/uploads/route.ts
import { createClient } from '@/lib/supabase/server'
import { auth } from '@clerk/nextjs'

export async function POST(req: Request) {
  const { userId } = auth()
  if (!userId) {
    return new Response('Unauthorized', { status: 401 })
  }

  const formData = await req.formData()
  const file = formData.get('file') as File

  // Validate file size (500MB limit)
  if (file.size > 500 * 1024 * 1024) {
    return new Response('File too large', { status: 400 })
  }

  // Validate file type
  const allowedTypes = [
    'application/pdf',
    'video/mp4',
    'audio/mpeg',
    'application/zip',
    'image/jpeg',
    'image/png',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  ]

  if (!allowedTypes.includes(file.type)) {
    return new Response('Invalid file type', { status: 400 })
  }

  const supabase = createClient()

  // Get user from Supabase
  const { data: user } = await supabase
    .from('users')
    .select('id')
    .eq('clerk_user_id', userId)
    .single()

  // Upload to Supabase Storage
  const fileName = `${user.id}/${Date.now()}-${file.name}`
  const { data, error } = await supabase.storage.from('product-files').upload(fileName, file, {
    cacheControl: '3600',
    upsert: false,
  })

  if (error) {
    return new Response('Upload failed', { status: 500 })
  }

  // Get public URL (will be converted to signed URL on download)
  const {
    data: { publicUrl },
  } = supabase.storage.from('product-files').getPublicUrl(data.path)

  return new Response(
    JSON.stringify({
      url: publicUrl,
      path: data.path,
      size: file.size,
      type: file.type,
    })
  )
}
```

### 7.3 Secure Download Links

```typescript
// app/api/download/[token]/route.ts
import { createClient } from '@/lib/supabase/server'
import { NextRequest } from 'next/server'

export async function GET(req: NextRequest, { params }: { params: { token: string } }) {
  const supabase = createClient()

  // Verify download token
  const { data: downloadLink } = await supabase
    .from('download_links')
    .select('*, order:orders(*), product:products(*)')
    .eq('token', params.token)
    .single()

  if (!downloadLink) {
    return new Response('Invalid download link', { status: 404 })
  }

  // Check expiration
  if (new Date(downloadLink.expires_at) < new Date()) {
    return new Response('Download link expired', { status: 410 })
  }

  // Check download limit
  if (downloadLink.download_count >= downloadLink.max_downloads) {
    return new Response('Download limit exceeded', { status: 429 })
  }

  // Increment download count
  await supabase
    .from('download_links')
    .update({ download_count: downloadLink.download_count + 1 })
    .eq('id', downloadLink.id)

  // Generate signed URL (valid for 1 hour)
  const { data: signedUrl } = await supabase.storage
    .from('product-files')
    .createSignedUrl(downloadLink.product.file_url, 3600)

  // Redirect to signed URL
  return Response.redirect(signedUrl.signedUrl)
}
```

### 7.4 Image Optimization

**Next.js Image Optimization:**

```typescript
// components/ProductCard.tsx
import Image from 'next/image'

export function ProductCard({ product }) {
  return (
    <div className="product-card">
      <Image
        src={product.cover_image_url}
        alt={product.title}
        width={400}
        height={300}
        quality={80}
        placeholder="blur"
        blurDataURL={product.blur_hash}
        sizes="(max-width: 768px) 100vw, 400px"
        priority={false}
      />
      {/* ... */}
    </div>
  )
}
```

**Blur Hash Generation (Server-side):**

```typescript
import { encode } from 'blurhash'
import sharp from 'sharp'

async function generateBlurHash(imageUrl: string): Promise<string> {
  const response = await fetch(imageUrl)
  const buffer = await response.arrayBuffer()

  const { data, info } = await sharp(Buffer.from(buffer))
    .raw()
    .ensureAlpha()
    .resize(32, 32, { fit: 'inside' })
    .toBuffer({ resolveWithObject: true })

  return encode(new Uint8ClampedArray(data), info.width, info.height, 4, 4)
}
```

---

## 8. Analytics & Monitoring

### 8.1 Analytics Stack

**Client-Side Tracking: PostHog**

```typescript
// lib/analytics/posthog.ts
import posthog from 'posthog-js'

export const initAnalytics = () => {
  if (typeof window !== 'undefined') {
    posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
      api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST || 'https://app.posthog.com',
      loaded: (posthog) => {
        if (process.env.NODE_ENV === 'development') posthog.debug()
      },
    })
  }
}

export const trackEvent = (eventName: string, properties?: Record<string, any>) => {
  posthog.capture(eventName, properties)
}

// Usage
trackEvent('product_viewed', {
  product_id: product.id,
  product_type: product.type,
  price: product.price,
})
```

**Server-Side Analytics (Supabase):**

```typescript
// lib/analytics/track.ts
import { createClient } from '@/lib/supabase/server'

export async function trackPageView(props: {
  userId?: string
  path: string
  referrer?: string
  sessionId: string
}) {
  const supabase = createClient()

  await supabase.from('analytics_events').insert({
    user_id: props.userId,
    event_type: 'page_view',
    event_data: {
      path: props.path,
      referrer: props.referrer,
    },
    session_id: props.sessionId,
  })
}
```

### 8.2 Error Tracking: Sentry

```typescript
// sentry.client.config.ts
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 0.1, // 10% of transactions for performance monitoring
  environment: process.env.NODE_ENV,
  integrations: [
    new Sentry.BrowserTracing({
      traceFetch: true,
      traceXHR: true,
    }),
  ],
  beforeSend(event, hint) {
    // Filter out sensitive data
    if (event.request) {
      delete event.request.cookies
      delete event.request.headers
    }
    return event
  },
})
```

### 8.3 Application Monitoring

**Health Check Endpoint:**

```typescript
// app/api/health/route.ts
import { createClient } from '@/lib/supabase/server'

export async function GET() {
  const checks = {
    database: false,
    storage: false,
    auth: false,
    timestamp: new Date().toISOString(),
  }

  try {
    // Check database
    const supabase = createClient()
    const { error: dbError } = await supabase.from('users').select('id').limit(1)
    checks.database = !dbError

    // Check storage
    const { data: buckets, error: storageError } = await supabase.storage.listBuckets()
    checks.storage = !storageError

    // Check Clerk auth
    checks.auth = !!process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY

    const allHealthy = Object.values(checks).every((v) => v === true || typeof v === 'string')

    return new Response(JSON.stringify(checks), {
      status: allHealthy ? 200 : 503,
      headers: { 'Content-Type': 'application/json' },
    })
  } catch (error) {
    return new Response(JSON.stringify({ error: 'Health check failed', checks }), {
      status: 503,
    })
  }
}
```

**Uptime Monitoring:**

- Use UptimeRobot (free) or Better Uptime
- Monitor `/api/health` every 5 minutes
- Alert via email/SMS if down

**Performance Monitoring:**

- Vercel Analytics (built-in)
- Core Web Vitals tracking
- API route performance
- Database query performance (Supabase dashboard)

---

## 9. Security Architecture

### 9.1 Security Layers

**1. Network Security**

- Cloudflare DDoS protection
- Rate limiting (100 requests/minute per IP)
- WAF (Web Application Firewall) rules
- Bot detection

**2. Application Security**

- HTTPS everywhere (TLS 1.3)
- CORS configuration
- CSP (Content Security Policy) headers
- XSS prevention (React auto-escaping)
- SQL injection prevention (Supabase parameterized queries)

**3. Authentication Security**

- JWT-based authentication (Clerk)
- HTTP-only cookies for session tokens
- Automatic token rotation
- MFA support (Phase 2)

**4. Data Security**

- Encryption at rest (AES-256)
- Encryption in transit (TLS 1.3)
- PII encryption in database
- Secure key management (environment variables)

### 9.2 Rate Limiting

**API Rate Limits:**

```typescript
// middleware.ts (after auth)
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(100, '1 m'), // 100 requests per minute
  analytics: true,
})

export async function rateLimit(req: Request) {
  const ip = req.headers.get('x-forwarded-for') || 'anonymous'
  const { success, limit, reset, remaining } = await ratelimit.limit(ip)

  if (!success) {
    return new Response('Rate limit exceeded', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': reset.toString(),
      },
    })
  }
}
```

**Payment Endpoint Stricter Limits:**

- 10 payment initiations per hour per user
- 3 failed payment attempts = temporary lock (15 minutes)
- Velocity checks for fraud detection

### 9.3 Content Security Policy

```typescript
// next.config.js
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: `
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline' *.clerk.com *.posthog.com;
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: blob: https:;
      font-src 'self' data:;
      connect-src 'self' *.supabase.co *.clerk.com *.posthog.com;
      frame-src 'self' *.clerk.com *.chapa.co;
    `
      .replace(/\s{2,}/g, ' ')
      .trim(),
  },
  {
    key: 'X-Frame-Options',
    value: 'SAMEORIGIN',
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff',
  },
  {
    key: 'Referrer-Policy',
    value: 'strict-origin-when-cross-origin',
  },
  {
    key: 'Permissions-Policy',
    value: 'camera=(), microphone=(), geolocation=()',
  },
]

module.exports = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: securityHeaders,
      },
    ]
  },
}
```

### 9.4 Webhook Security

```typescript
// Verify Chapa webhook signature
import crypto from 'crypto'

function verifyChapaSignature(payload: string, signature: string): boolean {
  const secret = process.env.CHAPA_WEBHOOK_SECRET!
  const expectedSignature = crypto.createHmac('sha256', secret).update(payload).digest('hex')

  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature))
}
```

---

## 10. Deployment Architecture

### 10.1 Infrastructure Stack

**Hosting:**

- **Frontend:** Vercel (Next.js optimized)
- **Backend:** Supabase (managed PostgreSQL + Edge Functions)
- **CDN:** Cloudflare (global edge network)
- **DNS:** Cloudflare (DDoS protection + SSL)

### 10.2 Environments

**Development:**

- Local Next.js dev server
- Supabase local development (Docker)
- `.env.local` for secrets

**Staging:**

- Vercel preview deployment (on PR)
- Supabase staging project
- Test Chapa test mode

**Production:**

- Vercel production deployment
- Supabase production project
- Live Chapa integration

### 10.3 CI/CD Pipeline

**GitHub Actions Workflow:**

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm run test

  deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

### 10.4 Database Migrations

**Supabase Migration Workflow:**

```bash
# Create new migration
supabase migration new add_discount_codes_table

# Edit migration file
# supabase/migrations/20250119_add_discount_codes_table.sql

# Apply migration locally
supabase db reset

# Push to production
supabase db push
```

**Migration File Example:**

```sql
-- supabase/migrations/20250119_add_discount_codes_table.sql
CREATE TABLE discount_codes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  creator_id UUID REFERENCES users(id) ON DELETE CASCADE,
  code TEXT UNIQUE NOT NULL,
  discount_type TEXT NOT NULL, -- percentage, fixed
  discount_value DECIMAL(10,2) NOT NULL,
  valid_from TIMESTAMP DEFAULT NOW(),
  valid_until TIMESTAMP,
  max_uses INTEGER,
  current_uses INTEGER DEFAULT 0,
  applies_to_products UUID[], -- Array of product IDs, null = all products
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_discount_codes_creator ON discount_codes(creator_id);
CREATE INDEX idx_discount_codes_code ON discount_codes(code);
```

---

## 11. Scalability Plan

### 11.1 Current Capacity (MVP)

**Expected Load:**

- 10,000 creators
- 50,000 customers
- 100,000 page views/day
- 5,000 transactions/day

**Infrastructure Capacity:**

- Vercel: Unlimited bandwidth (Pro plan)
- Supabase: 8GB database, 100GB bandwidth/month (Pro plan)
- Cloudflare: Unlimited requests (Free plan)

### 11.2 Scaling Triggers

**When to scale:**

- Database CPU >70% sustained
- API response time >500ms (p95)
- Storage >80% capacity
- 50,000+ active creators
- 10,000+ transactions/day

**Scaling Actions:**

**Phase 1 Scaling (0-50K users):**

- Add Supabase read replicas
- Implement aggressive caching (Redis)
- Optimize slow database queries
- Add database indexes

**Phase 2 Scaling (50K-500K users):**

- Migrate to dedicated Supabase instance
- Implement database sharding (by creator_id)
- Add separate analytics database
- Implement job queue (BullMQ + Redis)

**Phase 3 Scaling (500K+ users):**

- Migrate to self-hosted Postgres cluster
- Implement microservices architecture
- Add Kubernetes for container orchestration
- Global CDN with edge computing

### 11.3 Database Optimization

**Indexing Strategy:**

```sql
-- Frequently queried columns
CREATE INDEX CONCURRENTLY idx_products_creator_status ON products(creator_id, status);
CREATE INDEX CONCURRENTLY idx_orders_creator_created ON orders(creator_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_analytics_user_type_created ON analytics_events(user_id, event_type, created_at);

-- Full-text search for products
CREATE INDEX idx_products_search ON products USING GIN(to_tsvector('english', title || ' ' || description));
```

**Query Optimization:**

```sql
-- Bad: N+1 query problem
SELECT * FROM products WHERE creator_id = 'xxx';
-- Then for each product:
SELECT * FROM orders WHERE product_id = 'yyy';

-- Good: Join query
SELECT
  p.*,
  COUNT(o.id) as total_sales,
  SUM(o.amount) as total_revenue
FROM products p
LEFT JOIN orders o ON p.id = o.product_id AND o.payment_status = 'completed'
WHERE p.creator_id = 'xxx'
GROUP BY p.id;
```

**Caching Strategy:**

```typescript
// Cache creator storefront for 60 seconds
export const revalidate = 60

export async function generateStaticParams() {
  const supabase = createClient()
  const { data: users } = await supabase
    .from('users')
    .select('username')
    .eq('subscription_plan', ['creator', 'creator_pro'])

  return users.map((user) => ({
    username: user.username,
  }))
}
```

---

## 12. Disaster Recovery Plan

### 12.1 Backup Strategy

**Automated Backups:**

- Supabase: Daily automated backups (7-day retention)
- Weekly full backups exported to S3/R2 (30-day retention)
- Transaction logs: Real-time replication

**Backup Testing:**

- Monthly restore test to staging environment
- Quarterly full disaster recovery drill

### 12.2 Recovery Procedures

**Scenario 1: Database Corruption**

1. Stop all writes to database
2. Restore from most recent backup
3. Replay transaction logs from backup point
4. Verify data integrity
5. Resume normal operations

**Scenario 2: Complete Supabase Outage**

1. Enable maintenance mode on Vercel
2. Display status page to users
3. Switch DNS to backup static site
4. Monitor Supabase status
5. Once restored, sync any offline transactions

**Scenario 3: Vercel Outage**

1. Update DNS to point to Cloudflare Pages backup
2. Backup site serves read-only storefronts
3. Queue payment requests for processing when back online

### 12.3 Business Continuity

**Critical Operations During Outage:**

- Existing storefronts remain accessible (cached on CDN)
- Customer support via email/WhatsApp
- Manual payment processing if necessary
- Communication via status page + social media

**Recovery Time Objectives:**

- Database: <4 hours
- Frontend: <1 hour
- Payment processing: <2 hours

---

## 13. Ethiopian-Specific Optimizations

### 13.1 Low-Bandwidth Optimizations

**Adaptive Image Loading:**

```typescript
// Detect connection speed and serve appropriate images
import { useNetworkState } from 'react-use'

export function AdaptiveImage({ src, alt }) {
  const { effectiveType } = useNetworkState()

  const quality = effectiveType === 'slow-2g' || effectiveType === '2g'
    ? 50
    : effectiveType === '3g'
    ? 70
    : 80

  return (
    <Image
      src={src}
      alt={alt}
      quality={quality}
      priority={effectiveType === '4g'}
    />
  )
}
```

**Progressive Enhancement:**

```typescript
// Storefront works without JavaScript
export default function StorefrontPage({ user, products }) {
  return (
    <div>
      {/* Server-rendered, works without JS */}
      <h1>{user.full_name}</h1>
      <p>{user.bio}</p>

      {products.map(product => (
        <div key={product.id}>
          <h2>{product.title}</h2>
          <p>{product.price} ETB</p>
          {/* Form submission works without JS */}
          <form action="/api/checkout" method="POST">
            <input type="hidden" name="productId" value={product.id} />
            <button type="submit">Buy Now</button>
          </form>
        </div>
      ))}

      {/* Enhanced with JS when available */}
      <ClientEnhancements />
    </div>
  )
}
```

**Offline Support:**

```typescript
// Service Worker for offline functionality
// public/sw.js
const CACHE_NAME = 'fabrica-v1'
const urlsToCache = ['/', '/offline', '/styles/main.css', '/scripts/main.js']

self.addEventListener('install', (event) => {
  event.waitUntil(caches.open(CACHE_NAME).then((cache) => cache.addAll(urlsToCache)))
})

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches
      .match(event.request)
      .then((response) => response || fetch(event.request))
      .catch(() => caches.match('/offline'))
  )
})
```

### 13.2 Chapa Payment Integration Considerations

**Phone Number Validation:**

```typescript
// Ethiopian phone number format: +251 9XX XXX XXX
export function validateEthiopianPhone(phone: string): boolean {
  const regex = /^(\+251|0)?9\d{8}$/
  return regex.test(phone.replace(/\s/g, ''))
}

export function formatEthiopianPhone(phone: string): string {
  const cleaned = phone.replace(/\D/g, '')
  if (cleaned.startsWith('251')) {
    return `+251 ${cleaned.slice(3, 5)} ${cleaned.slice(5, 8)} ${cleaned.slice(8)}`
  }
  if (cleaned.startsWith('09')) {
    return `+251 ${cleaned.slice(1, 3)} ${cleaned.slice(3, 6)} ${cleaned.slice(6)}`
  }
  return phone
}
```

**Currency Formatting:**

```typescript
export function formatETB(amount: number): string {
  return new Intl.NumberFormat('en-ET', {
    style: 'currency',
    currency: 'ETB',
    minimumFractionDigits: 2,
  }).format(amount)
}

// Output: "ETB 1,299.00"
```

---

## 14. Technology Decision Log

### 14.1 Why Next.js?

**Pros:**

- Server-side rendering for low-bandwidth optimization
- Built-in API routes (no separate backend needed)
- Excellent AI code generation support (Cursor, Bolt, Lovable)
- Automatic code splitting and optimization
- Vercel deployment (zero-config)

**Alternatives Considered:**

- **Remix:** Similar benefits but smaller ecosystem
- **SvelteKit:** Smaller bundle size but less AI tooling support
- **React SPA:** Worse performance on slow networks

### 14.2 Why Supabase?

**Pros:**

- PostgreSQL (mature, reliable, powerful)
- Built-in authentication (can replace Clerk if needed)
- Real-time subscriptions
- Edge Functions (serverless backend)
- Generous free tier, affordable scaling
- Row Level Security (RLS) for data protection

**Alternatives Considered:**

- **Firebase:** NoSQL not ideal for transactional data
- **PlanetScale:** No edge functions, more expensive
- **AWS RDS:** More complex, expensive, no free tier

### 14.3 Why Clerk?

**Pros:**

- Best-in-class authentication UX
- Pre-built UI components
- Webhook support for syncing users
- MFA support (future)
- Ethiopian phone number support

**Alternatives Considered:**

- **NextAuth:** Free but more setup required
- **Supabase Auth:** Good but Clerk has better UX
- **Auth0:** More expensive

### 14.4 Why Vercel?

**Pros:**

- Zero-config Next.js deployment
- Global edge network
- Automatic preview deployments
- Web Analytics included
- Generous free tier

**Alternatives Considered:**

- **Netlify:** Similar but Vercel better for Next.js
- **Cloudflare Pages:** Cheaper at scale but less Next.js optimization
- **Self-hosted:** Too complex for MVP

---

## 15. Future Architecture Enhancements

### 15.1 Phase 2 (Feb-Mar 2026)

**Caching Layer (Redis):**

```typescript
import { Redis } from '@upstash/redis'

const redis = Redis.fromEnv()

// Cache creator storefront
export async function getCreatorStorefront(username: string) {
  const cached = await redis.get(`storefront:${username}`)
  if (cached) return cached

  const storefront = await fetchFromDatabase(username)
  await redis.setex(`storefront:${username}`, 300, storefront) // 5 min cache

  return storefront
}
```

**Job Queue (BullMQ):**

```typescript
// For background tasks: email sending, analytics aggregation, payout processing
import { Queue, Worker } from 'bullmq'

const emailQueue = new Queue('email', { connection: redis })

// Add job
await emailQueue.add('send-confirmation', {
  to: customer.email,
  orderId: order.id,
})

// Process job
new Worker(
  'email',
  async (job) => {
    await sendEmail(job.data)
  },
  { connection: redis }
)
```

### 15.2 Phase 3 (Apr-Jun 2026)

**Search Service (Algolia/Typesense):**

- Full-text search across products
- Faceted filtering
- Search analytics

**Analytics Warehouse (BigQuery/ClickHouse):**

- Separate OLAP database for complex analytics
- Daily ETL from PostgreSQL
- Support for large-scale reporting

### 15.3 Long-term (2027)

**Microservices Architecture:**

```
User Service (Auth, Profiles)
  ↓
Product Service (CRUD, Inventory)
  ↓
Payment Service (Chapa - supports Telebirr and other methods, Refunds)
  ↓
Order Service (Order Management)
  ↓
Notification Service (Email, SMS, Push)
  ↓
Analytics Service (Tracking, Reporting)
```

**Event-Driven Architecture:**

- Apache Kafka or AWS EventBridge for event streaming
- Decoupled services communicating via events
- Event sourcing for audit trails
- CQRS (Command Query Responsibility Segregation)

**Global Infrastructure:**

- Multi-region deployment (East Africa, Europe, North America)
- Data residency compliance
- CDN edge computing
- Regional database replicas

---

## 16. Monitoring & Observability

### 16.1 Logging Strategy

**Structured Logging:**

```typescript
// lib/logger.ts
import pino from 'pino'

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  formatters: {
    level: (label) => {
      return { level: label }
    },
  },
  redact: {
    paths: ['*.password', '*.token', '*.apiKey'],
    remove: true,
  },
})

export function logPaymentAttempt(orderId: string, amount: number, status: string) {
  logger.info({
    event: 'payment_attempt',
    orderId,
    amount,
    status,
    timestamp: new Date().toISOString(),
  })
}
```

**Log Aggregation:**

- Vercel: Automatic log collection
- Supabase: Edge Function logs
- External: Send to Better Stack (formerly Logtail) or Datadog

### 16.2 Metrics Dashboard

**Key Metrics to Track:**

**Business Metrics:**

- MRR (Monthly Recurring Revenue)
- Churn rate
- Trial → Paid conversion rate
- Average Revenue Per User (ARPU)
- Customer Acquisition Cost (CAC)
- Lifetime Value (LTV)

**Technical Metrics:**

- API response times (p50, p95, p99)
- Error rates (by endpoint)
- Database query performance
- CDN cache hit rate
- File upload success rate
- Payment success rate

**User Metrics:**

- Daily/Monthly Active Users (DAU/MAU)
- Storefront views
- Product creation rate
- Order completion rate
- Checkout abandonment rate

### 16.3 Alerting Rules

**Critical Alerts (PagerDuty/Slack):**

- Database CPU >90% for >5 minutes
- API error rate >5% for >2 minutes
- Payment success rate <90% for >5 minutes
- Application downtime (health check fails)
- Security breach detected

**Warning Alerts (Email):**

- Database CPU >70% for >15 minutes
- Storage >80% capacity
- Unusual traffic spike (10x normal)
- Failed payment webhook deliveries

---

## 17. Development Workflow

### 17.1 Local Development Setup

**Prerequisites:**

```bash
# Install dependencies
node v18+
npm or pnpm
Docker (for Supabase local)
```

**Setup Steps:**

```bash
# Clone repository
git clone https://github.com/yourorg/fabrica.git
cd fabrica

# Install dependencies
npm install

# Setup Supabase locally
npx supabase init
npx supabase start

# Copy environment variables
cp .env.example .env.local

# Run database migrations
npx supabase db reset

# Start development server
npm run dev
```

**Environment Variables:**

```bash
# .env.local
# Supabase
NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Clerk
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxx
CLERK_SECRET_KEY=sk_test_xxx
CLERK_WEBHOOK_SECRET=whsec_xxx

# Chapa (Test Mode)
CHAPA_SECRET_KEY=CHASECK_TEST-your_test_secret_key
CHAPA_WEBHOOK_SECRET=test_webhook_secret

# Resend
RESEND_API_KEY=re_xxx

# Sentry
NEXT_PUBLIC_SENTRY_DSN=https://xxx@sentry.io/xxx

# PostHog
NEXT_PUBLIC_POSTHOG_KEY=phc_xxx
NEXT_PUBLIC_POSTHOG_HOST=https://app.posthog.com

# App URL
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

### 17.2 Testing Strategy

**Unit Tests (Jest + React Testing Library):**

```typescript
// __tests__/lib/utils/currency.test.ts
import { formatETB } from '@/lib/utils/currency'

describe('formatETB', () => {
  it('formats Ethiopian Birr correctly', () => {
    expect(formatETB(1299.5)).toBe('ETB 1,299.50')
    expect(formatETB(0)).toBe('ETB 0.00')
    expect(formatETB(1000000)).toBe('ETB 1,000,000.00')
  })
})
```

**Integration Tests:**

```typescript
// __tests__/api/products/create.test.ts
import { createMocks } from 'node-mocks-http'
import handler from '@/app/api/products/route'

describe('/api/products POST', () => {
  it('creates a product for authenticated user', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        title: 'Test Product',
        price: 99.99,
        type: 'digital',
      },
      headers: {
        authorization: 'Bearer test-token',
      },
    })

    await handler(req, res)

    expect(res._getStatusCode()).toBe(201)
    expect(JSON.parse(res._getData())).toMatchObject({
      title: 'Test Product',
      price: 99.99,
    })
  })
})
```

**End-to-End Tests (Playwright):**

```typescript
// e2e/checkout.spec.ts
import { test, expect } from '@playwright/test'

test('complete checkout flow', async ({ page }) => {
  // Visit storefront
  await page.goto('/abeba')

  // Click product
  await page.click('text=Ethiopian Coffee Guide')

  // Fill checkout form
  await page.fill('input[name="name"]', 'Test Customer')
  await page.fill('input[name="email"]', 'test@example.com')
  await page.fill('input[name="phone"]', '0911223344')

  // Submit (mock Chapa in test)
  await page.click('button:has-text("Pay with Telebirr")') // Telebirr via Chapa

  // Verify confirmation page
  await expect(page).toHaveURL(/order-confirmation/)
  await expect(page.locator('text=Download your product')).toBeVisible()
})
```

### 17.3 Code Quality

**ESLint Configuration:**

```javascript
// .eslintrc.js
module.exports = {
  extends: ['next/core-web-vitals', 'plugin:@typescript-eslint/recommended', 'prettier'],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    'no-console': ['warn', { allow: ['warn', 'error'] }],
  },
}
```

**Pre-commit Hooks (Husky):**

```json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{ts,tsx}": ["eslint --fix", "prettier --write"]
  }
}
```

---

## 18. API Design Patterns

### 18.1 RESTful API Structure

**Endpoint Naming:**

```
GET    /api/products              # List products
POST   /api/products              # Create product
GET    /api/products/:id          # Get product details
PATCH  /api/products/:id          # Update product
DELETE /api/products/:id          # Delete product

GET    /api/orders                # List orders
GET    /api/orders/:id            # Get order details
POST   /api/orders/:id/refund     # Refund order

GET    /api/analytics/overview    # Get analytics overview
GET    /api/analytics/revenue     # Get revenue analytics

POST   /api/payments/initiate     # Initiate payment
POST   /api/webhooks/chapa        # Payment webhook
```

**Response Format:**

```typescript
// Success response
{
  success: true,
  data: {
    id: "123",
    title: "Product Name",
    price: 99.99
  },
  meta: {
    timestamp: "2025-01-19T10:00:00Z"
  }
}

// Error response
{
  success: false,
  error: {
    code: "PRODUCT_NOT_FOUND",
    message: "Product with ID 123 not found",
    details: {}
  },
  meta: {
    timestamp: "2025-01-19T10:00:00Z"
  }
}

// List response with pagination
{
  success: true,
  data: [...],
  pagination: {
    page: 1,
    limit: 20,
    total: 157,
    totalPages: 8
  }
}
```

### 18.2 Error Handling

**Standard Error Codes:**

```typescript
export const ErrorCodes = {
  // Authentication (401)
  UNAUTHORIZED: 'UNAUTHORIZED',
  INVALID_TOKEN: 'INVALID_TOKEN',
  TOKEN_EXPIRED: 'TOKEN_EXPIRED',

  // Authorization (403)
  FORBIDDEN: 'FORBIDDEN',
  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',

  // Not Found (404)
  RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  PRODUCT_NOT_FOUND: 'PRODUCT_NOT_FOUND',

  // Validation (400)
  INVALID_INPUT: 'INVALID_INPUT',
  MISSING_REQUIRED_FIELD: 'MISSING_REQUIRED_FIELD',
  INVALID_FILE_TYPE: 'INVALID_FILE_TYPE',
  FILE_TOO_LARGE: 'FILE_TOO_LARGE',

  // Payment (402)
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  INSUFFICIENT_FUNDS: 'INSUFFICIENT_FUNDS',

  // Rate Limiting (429)
  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',

  // Server Error (500)
  INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',
}
```

**Error Handler Middleware:**

```typescript
// lib/api/errorHandler.ts
import { NextResponse } from 'next/server'

export class APIError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number = 500,
    public details?: any
  ) {
    super(message)
  }
}

export function handleAPIError(error: unknown) {
  if (error instanceof APIError) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: error.code,
          message: error.message,
          details: error.details,
        },
      },
      { status: error.statusCode }
    )
  }

  // Log unexpected errors to Sentry
  console.error('Unexpected error:', error)

  return NextResponse.json(
    {
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'An unexpected error occurred',
      },
    },
    { status: 500 }
  )
}
```

---

## 19. Data Migration Strategy

### 19.1 Zero-Downtime Migrations

**Process:**

1. Create new database column/table
2. Write to both old and new schemas
3. Migrate existing data in background
4. Switch reads to new schema
5. Remove old schema after validation

**Example: Adding Discount Codes**

```sql
-- Step 1: Add new table
CREATE TABLE discount_codes (...);

-- Step 2: Update application to write to both places
-- (handled in application code)

-- Step 3: Backfill data (if needed)
-- None needed for new feature

-- Step 4: Switch reads
-- (handled in application code)

-- Step 5: Remove old columns (if any)
-- None to remove
```

### 19.2 Data Seeding

**Development Seeds:**

```typescript
// supabase/seed.ts
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!)

async function seed() {
  // Create test users
  const { data: users } = await supabase
    .from('users')
    .insert([
      {
        clerk_user_id: 'user_test1',
        email: 'abeba@test.com',
        username: 'abeba',
        full_name: 'Abeba Tesfa',
        subscription_plan: 'creator_pro',
      },
      {
        clerk_user_id: 'user_test2',
        email: 'daniel@test.com',
        username: 'daniel',
        full_name: 'Daniel Kebede',
        subscription_plan: 'creator',
      },
    ])
    .select()

  // Create test products
  await supabase.from('products').insert([
    {
      creator_id: users[0].id,
      type: 'digital',
      title: 'Ethiopian Coffee Guide',
      description: 'Complete guide to Ethiopian coffee culture',
      price: 299.99,
      status: 'active',
    },
    {
      creator_id: users[0].id,
      type: 'booking',
      title: '30-Min Business Coaching',
      price: 999.0,
      duration_minutes: 30,
      status: 'active',
    },
  ])

  console.log('✅ Database seeded successfully')
}

seed().catch(console.error)
```

---

## 20. Performance Benchmarks

### 20.1 Target Metrics

| Metric                         | Target | Measurement        |
| ------------------------------ | ------ | ------------------ |
| Homepage Load (3G)             | <2s    | Lighthouse         |
| Storefront Load (3G)           | <2.5s  | Lighthouse         |
| Dashboard Load (4G)            | <1.5s  | Lighthouse         |
| API Response Time (p95)        | <200ms | Vercel Analytics   |
| Database Query Time (p95)      | <50ms  | Supabase Dashboard |
| Checkout Completion Time       | <30s   | User timing        |
| Time to First Byte (TTFB)      | <600ms | WebPageTest        |
| Largest Contentful Paint (LCP) | <2.5s  | Core Web Vitals    |
| First Input Delay (FID)        | <100ms | Core Web Vitals    |
| Cumulative Layout Shift (CLS)  | <0.1   | Core Web Vitals    |

### 20.2 Load Testing

**Artillery Configuration:**

```yaml
# load-test.yml
config:
  target: 'https://fabrica.et'
  phases:
    - duration: 60
      arrivalRate: 10
      name: 'Warm up'
    - duration: 120
      arrivalRate: 50
      name: 'Sustained load'
    - duration: 60
      arrivalRate: 100
      name: 'Spike test'
scenarios:
  - name: 'Browse storefront'
    flow:
      - get:
          url: '/abeba'
      - think: 3
      - get:
          url: '/api/products?creator=abeba'
  - name: 'Complete checkout'
    flow:
      - post:
          url: '/api/payments/initiate'
          json:
            productId: '{{productId}}'
            customerEmail: 'test@example.com'
```

---

## 21. Documentation Standards

### 21.1 Code Documentation

**Function Documentation:**

```typescript
/**
 * Generates a time-limited signed URL for product download
 *
 * @param orderId - The order ID associated with the product
 * @param productId - The product ID to generate download link for
 * @param expiryHours - Hours until link expires (default: 720 = 30 days)
 * @returns Object containing download token and expiry timestamp
 *
 * @example
 * const link = await generateDownloadLink('order_123', 'prod_456', 24)
 * console.log(link.token) // "dl_abc123xyz"
 */
export async function generateDownloadLink(
  orderId: string,
  productId: string,
  expiryHours: number = 720
): Promise<{ token: string; expiresAt: Date }> {
  // Implementation
}
```

**API Documentation (OpenAPI/Swagger):**

```yaml
# docs/api.yaml
openapi: 3.0.0
info:
  title: Fabrica API
  version: 1.0.0
paths:
  /api/products:
    post:
      summary: Create a new product
      security:
        - BearerAuth: []
      requestBody:
        content:
          application/json:
            schema:
              type: object
              required:
                - title
                - type
                - price
              properties:
                title:
                  type: string
                  example: 'Ethiopian Coffee Guide'
                type:
                  type: string
                  enum: [digital, booking, link]
                price:
                  type: number
                  example: 299.99
      responses:
        201:
          description: Product created successfully
        401:
          description: Unauthorized
```

### 21.2 README Structure

**Main README.md:**

```markdown
# Fabrica

Ethiopian creator commerce platform.

## Quick Start

\`\`\`bash
npm install
npm run dev
\`\`\`

## Documentation

- [Architecture](./docs/architecture.md)
- [API Reference](./docs/api.md)
- [Deployment](./docs/deployment.md)
- [Contributing](./CONTRIBUTING.md)

## Tech Stack

- Next.js 14
- Supabase
- Clerk
- Tailwind CSS

## License

MIT
```

---

## 22. Architecture Decision Records (ADRs)

### ADR-001: Use Next.js App Router over Pages Router

**Status:** Accepted  
**Date:** 2025-01-19

**Context:**
Need to choose between Next.js App Router (new) and Pages Router (legacy).

**Decision:**
Use App Router for MVP.

**Consequences:**

- ✅ Better performance (React Server Components)
- ✅ Improved routing with layouts
- ✅ Built-in loading/error states
- ❌ Smaller community (newer)
- ❌ Some libraries not yet compatible

---

### ADR-002: Clerk for Authentication vs NextAuth

**Status:** Accepted  
**Date:** 2025-01-19

**Context:**
Need authentication solution with good UX and Ethiopian phone support.

**Decision:**
Use Clerk for authentication.

**Consequences:**

- ✅ Best-in-class UX
- ✅ Phone number authentication
- ✅ Webhooks for user sync
- ✅ Pre-built components
- ❌ Paid service ($25/mo after 10K MAU)
- ❌ Vendor lock-in

---

### ADR-003: Monorepo vs Separate Repositories

**Status:** Accepted  
**Date:** 2025-01-19

**Context:**
Deciding repository structure for web app, mobile app (future), and shared packages.

**Decision:**
Start with single repository (monolith), split later if needed.

**Consequences:**

- ✅ Simpler for solo development
- ✅ Easier to share code
- ✅ Single deployment pipeline
- ❌ Harder to scale teams later
- ❌ Longer CI/CD times at scale

---

## 23. Conclusion

This architecture document provides a comprehensive blueprint for building Fabrica as a scalable, secure, and performant creator commerce platform optimized for the Ethiopian market.

### Key Architectural Strengths:

1. **Mobile-First:** Optimized for low-bandwidth Ethiopian networks
2. **Scalable:** Designed to handle 50K+ creators without major changes
3. **Secure:** Multiple security layers, encryption, PCI compliance
4. **Cost-Effective:** Free tiers and pay-as-you-grow services
5. **Developer-Friendly:** AI coding tool compatible, well-documented

### Next Steps:

1. Review and approve this architecture
2. Set up development environment
3. Create detailed technical specifications
4. Begin MVP development with Phase 1 features
5. Conduct security audit before launch

---

**Document Metadata:**

- **Version:** 1.0
- **Last Updated:** November 19, 2025
- **Next Review:** February 1, 2026
- **Owner:** Fabrica Engineering Team
- **Status:** Approved for MVP Development
