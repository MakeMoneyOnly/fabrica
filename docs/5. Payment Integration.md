# Fabrica - Telebirr Payment Integration Guide

**Version:** 1.0  
**Last Updated:** November 19, 2025  
**Integration Type:** RESTful API  
**Primary Market:** Ethiopia

---

## 1. Overview

This document provides a comprehensive guide for integrating Telebirr payment processing into Fabrica, including API specifications, security implementation, error handling, and testing procedures.

### What is Telebirr?

Telebirr is Ethiopia's leading mobile money platform operated by Ethio Telecom, enabling users to send money, pay bills, and make purchases using their mobile phones. It's the most widely adopted digital payment method in Ethiopia.

### Integration Goals

1. **Seamless Payment Flow:** One-click checkout experience
2. **Security:** PCI-compliant, encrypted transactions
3. **Reliability:** Fallback mechanisms for failed transactions
4. **Ethiopian UX:** Optimized for Ethiopian users and network conditions
5. **Webhook Processing:** Real-time payment confirmations

---

## 2. Prerequisites

### 2.1 Requirements

**Business Requirements:**
- Registered Ethiopian business entity
- Telebirr merchant account
- Valid TIN (Tax Identification Number)
- Business bank account

**Technical Requirements:**
- HTTPS-enabled domain (required for webhooks)
- Server with Node.js/TypeScript support
- Database for transaction logging
- Webhook endpoint capacity (handle 100+ req/min)

### 2.2 Account Setup

**Steps to Get Telebirr Merchant Account:**

1. **Apply for Merchant Account:**
   - Visit Telebirr business portal
   - Submit business documents (license, TIN, bank statements)
   - Complete KYC verification
   - Expected approval: 5-10 business days

2. **Receive API Credentials:**
   - App ID (unique identifier)
   - App Key (secret key for signing)
   - Merchant Code (your merchant identifier)
   - Webhook Secret (for verifying webhook signatures)

3. **Test Environment Access:**
   - Sandbox API URL
   - Test App ID/Key
   - Test phone numbers for simulation

### 2.3 API Credentials Storage

```typescript
// .env.production
TELEBIRR_APP_ID=your_app_id_here
TELEBIRR_APP_KEY=your_app_key_here
TELEBIRR_MERCHANT_CODE=your_merchant_code
TELEBIRR_WEBHOOK_SECRET=your_webhook_secret
TELEBIRR_API_URL=https://api.telebirr.et/v2

// .env.local (development)
TELEBIRR_APP_ID=test_app_id
TELEBIRR_APP_KEY=test_app_key
TELEBIRR_MERCHANT_CODE=test_merchant
TELEBIRR_WEBHOOK_SECRET=test_webhook_secret
TELEBIRR_API_URL=https://sandbox.telebirr.et/v2
```

---

## 3. API Endpoints

### 3.1 Initiate Payment

**Endpoint:** `POST /v2/payment/initiate`

**Purpose:** Create a payment request and receive payment URL

**Request:**
```typescript
interface InitiatePaymentRequest {
  appId: string              // Your App ID
  appKey: string             // Your App Key (hashed)
  merchantCode: string       // Your merchant code
  transactionId: string      // Unique transaction ID (from your system)
  amount: number             // Amount in ETB (e.g., 299.99)
  subject: string            // Payment description (max 100 chars)
  outTradeNo: string         // Order number (must be unique)
  notifyUrl: string          // Webhook URL for payment notification
  returnUrl: string          // URL to redirect after payment
  timeoutExpress: string     // Payment timeout (e.g., "30m")
  nonce: string              // Random string for security
  timestamp: number          // Unix timestamp
  sign: string               // Request signature (HMAC-SHA256)
}
```

**Response (Success):**
```json
{
  "code": "0",
  "msg": "success",
  "data": {
    "toPayUrl": "https://app.telebirr.et/pay?token=xxx",
    "transactionId": "TBR_20250119_XXXX"
  }
}
```

**Response (Error):**
```json
{
  "code": "1001",
  "msg": "Invalid signature",
  "data": null
}
```

---

### 3.2 Query Payment Status

**Endpoint:** `POST /v2/payment/query`

**Purpose:** Check payment status (for reconciliation)

**Request:**
```typescript
interface QueryPaymentRequest {
  appId: string
  merchantCode: string
  outTradeNo: string         // Your order number
  nonce: string
  timestamp: number
  sign: string
}
```

**Response:**
```json
{
  "code": "0",
  "msg": "success",
  "data": {
    "outTradeNo": "FAB-20250119-0001",
    "transactionId": "TBR_20250119_XXXX",
    "tradeStatus": "SUCCESS",  // SUCCESS, FAILED, PENDING, CLOSED
    "amount": "299.99",
    "paidAt": "2025-01-19T10:30:00Z"
  }
}
```

---

### 3.3 Refund Payment

**Endpoint:** `POST /v2/payment/refund`

**Purpose:** Issue refund for completed payment

**Request:**
```typescript
interface RefundPaymentRequest {
  appId: string
  merchantCode: string
  outTradeNo: string         // Original order number
  refundAmount: number       // Amount to refund
  refundReason: string       // Reason for refund
  nonce: string
  timestamp: number
  sign: string
}
```

**Response:**
```json
{
  "code": "0",
  "msg": "success",
  "data": {
    "refundId": "REF_20250119_XXXX",
    "status": "SUCCESS",
    "refundedAt": "2025-01-19T11:00:00Z"
  }
}
```

---

## 4. Implementation

### 4.1 TypeScript SDK

```typescript
// lib/payments/telebirr.ts
import crypto from 'crypto'

interface TelebirrConfig {
  appId: string
  appKey: string
  merchantCode: string
  apiUrl: string
}

class TelebirrClient {
  private config: TelebirrConfig

  constructor(config: TelebirrConfig) {
    this.config = config
  }

  /**
   * Generate signature for API request
   */
  private generateSignature(params: Record<string, any>): string {
    // Sort parameters alphabetically
    const sortedKeys = Object.keys(params).sort()
    
    // Create query string
    const queryString = sortedKeys
      .map(key => `${key}=${params[key]}`)
      .join('&')
    
    // Add app key
    const signString = queryString + '&key=' + this.config.appKey
    
    // Generate HMAC-SHA256 signature
    return crypto
      .createHmac('sha256', this.config.appKey)
      .update(signString)
      .digest('hex')
      .toUpperCase()
  }

  /**
   * Initiate payment
   */
  async initiatePayment(params: {
    orderId: string
    amount: number
    subject: string
    customerName: string
    customerPhone: string
    returnUrl: string
    notifyUrl: string
  }): Promise<{ success: boolean; paymentUrl?: string; error?: string }> {
    try {
      const nonce = crypto.randomBytes(16).toString('hex')
      const timestamp = Date.now()

      const requestParams = {
        appId: this.config.appId,
        merchantCode: this.config.merchantCode,
        transactionId: `FAB_${timestamp}`,
        amount: params.amount.toFixed(2),
        subject: params.subject,
        outTradeNo: params.orderId,
        notifyUrl: params.notifyUrl,
        returnUrl: params.returnUrl,
        timeoutExpress: '30m',
        nonce,
        timestamp,
      }

      const sign = this.generateSignature(requestParams)

      const response = await fetch(`${this.config.apiUrl}/payment/initiate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...requestParams,
          sign,
        }),
      })

      const data = await response.json()

      if (data.code === '0') {
        return {
          success: true,
          paymentUrl: data.data.toPayUrl,
        }
      } else {
        return {
          success: false,
          error: data.msg,
        }
      }
    } catch (error) {
      console.error('Telebirr initiate payment error:', error)
      return {
        success: false,
        error: 'Payment initiation failed',
      }
    }
  }

  /**
   * Query payment status
   */
  async queryPayment(orderId: string): Promise<{
    success: boolean
    status?: 'SUCCESS' | 'FAILED' | 'PENDING' | 'CLOSED'
    transactionId?: string
    paidAt?: string
    error?: string
  }> {
    try {
      const nonce = crypto.randomBytes(16).toString('hex')
      const timestamp = Date.now()

      const requestParams = {
        appId: this.config.appId,
        merchantCode: this.config.merchantCode,
        outTradeNo: orderId,
        nonce,
        timestamp,
      }

      const sign = this.generateSignature(requestParams)

      const response = await fetch(`${this.config.apiUrl}/payment/query`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...requestParams,
          sign,
        }),
      })

      const data = await response.json()

      if (data.code === '0') {
        return {
          success: true,
          status: data.data.tradeStatus,
          transactionId: data.data.transactionId,
          paidAt: data.data.paidAt,
        }
      } else {
        return {
          success: false,
          error: data.msg,
        }
      }
    } catch (error) {
      console.error('Telebirr query payment error:', error)
      return {
        success: false,
        error: 'Payment query failed',
      }
    }
  }

  /**
   * Process refund
   */
  async refundPayment(params: {
    orderId: string
    refundAmount: number
    reason: string
  }): Promise<{ success: boolean; refundId?: string; error?: string }> {
    try {
      const nonce = crypto.randomBytes(16).toString('hex')
      const timestamp = Date.now()

      const requestParams = {
        appId: this.config.appId,
        merchantCode: this.config.merchantCode,
        outTradeNo: params.orderId,
        refundAmount: params.refundAmount.toFixed(2),
        refundReason: params.reason,
        nonce,
        timestamp,
      }

      const sign = this.generateSignature(requestParams)

      const response = await fetch(`${this.config.apiUrl}/payment/refund`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...requestParams,
          sign,
        }),
      })

      const data = await response.json()

      if (data.code === '0') {
        return {
          success: true,
          refundId: data.data.refundId,
        }
      } else {
        return {
          success: false,
          error: data.msg,
        }
      }
    } catch (error) {
      console.error('Telebirr refund error:', error)
      return {
        success: false,
        error: 'Refund processing failed',
      }
    }
  }

  /**
   * Verify webhook signature
   */
  verifyWebhookSignature(payload: string, signature: string): boolean {
    const expectedSignature = crypto
      .createHmac('sha256', process.env.TELEBIRR_WEBHOOK_SECRET!)
      .update(payload)
      .digest('hex')
      .toUpperCase()

    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    )
  }
}

// Export singleton instance
export const telebirrClient = new TelebirrClient({
  appId: process.env.TELEBIRR_APP_ID!,
  appKey: process.env.TELEBIRR_APP_KEY!,
  merchantCode: process.env.TELEBIRR_MERCHANT_CODE!,
  apiUrl: process.env.TELEBIRR_API_URL!,
})
```

---

### 4.2 Payment Initiation API Route

```typescript
// app/api/payments/initiate/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { telebirrClient } from '@/lib/payments/telebirr'

export async function POST(req: NextRequest) {
  try {
    const { productId, customerEmail, customerName, customerPhone } = await req.json()

    // Validate input
    if (!productId || !customerEmail || !customerName) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      )
    }

    const supabase = createClient()

    // Fetch product details
    const { data: product, error: productError } = await supabase
      .from('products')
      .select('*, creator:users!creator_id(*)')
      .eq('id', productId)
      .single()

    if (productError || !product) {
      return NextResponse.json(
        { error: 'Product not found' },
        { status: 404 }
      )
    }

    // Create pending order
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert({
        product_id: productId,
        creator_id: product.creator_id,
        customer_email: customerEmail,
        customer_name: customerName,
        customer_phone: customerPhone,
        product_title: product.title,
        product_type: product.type,
        amount: product.price,
        subtotal: product.price,
        currency: 'ETB',
        payment_provider: 'telebirr',
        payment_status: 'pending',
      })
      .select()
      .single()

    if (orderError) {
      console.error('Order creation error:', orderError)
      return NextResponse.json(
        { error: 'Failed to create order' },
        { status: 500 }
      )
    }

    // Initiate Telebirr payment
    const paymentResult = await telebirrClient.initiatePayment({
      orderId: order.order_number,
      amount: product.price,
      subject: `${product.title} - Fabrica`,
      customerName,
      customerPhone,
      returnUrl: `${process.env.NEXT_PUBLIC_APP_URL}/order-confirmation/${order.id}`,
      notifyUrl: `${process.env.NEXT_PUBLIC_APP_URL}/api/webhooks/telebirr`,
    })

    if (!paymentResult.success) {
      // Update order status to failed
      await supabase
        .from('orders')
        .update({ payment_status: 'failed' })
        .eq('id', order.id)

      return NextResponse.json(
        { error: paymentResult.error || 'Payment initiation failed' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      orderId: order.id,
      paymentUrl: paymentResult.paymentUrl,
    })
  } catch (error) {
    console.error('Payment initiation error:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

---

### 4.3 Webhook Handler

```typescript
// app/api/webhooks/telebirr/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/admin'
import { telebirrClient } from '@/lib/payments/telebirr'
import { sendOrderConfirmationEmail } from '@/lib/email/templates'

export async function POST(req: NextRequest) {
  try {
    const signature = req.headers.get('x-telebirr-signature')
    if (!signature) {
      return new Response('Missing signature', { status: 401 })
    }

    const payload = await req.text()
    
    // Verify webhook signature
    if (!telebirrClient.verifyWebhookSignature(payload, signature)) {
      console.error('Invalid webhook signature')
      return new Response('Invalid signature', { status: 401 })
    }

    const data = JSON.parse(payload)
    const { outTradeNo, tradeStatus, transactionId, amount, paidAt } = data

    const supabase = createClient()

    // Find order
    const { data: order, error: orderError } = await supabase
      .from('orders')
      .select('*, product:products(*), creator:users!creator_id(*)')
      .eq('order_number', outTradeNo)
      .single()

    if (orderError || !order) {
      console.error('Order not found:', outTradeNo)
      return new Response('Order not found', { status: 404 })
    }

    // Prevent duplicate processing
    if (order.payment_status === 'completed') {
      return new Response('Already processed', { status: 200 })
    }

    // Update order status based on payment result
    if (tradeStatus === 'SUCCESS') {
      const { error: updateError } = await supabase
        .from('orders')
        .update({
          payment_status: 'completed',
          payment_provider_id: transactionId,
          paid_at: paidAt,
          fulfilled_at: new Date().toISOString(),
          fulfillment_status: 'fulfilled',
        })
        .eq('id', order.id)

      if (updateError) {
        console.error('Order update error:', updateError)
        return new Response('Update failed', { status: 500 })
      }

      // Generate download link for digital products
      if (order.product.type === 'digital') {
        const token = crypto.randomBytes(32).toString('base64url')
        const expiresAt = new Date()
        expiresAt.setDate(expiresAt.getDate() + 30) // 30 days

        await supabase.from('download_links').insert({
          order_id: order.id,
          product_id: order.product_id,
          token,
          expires_at: expiresAt.toISOString(),
          max_downloads: 3,
        })
      }

      // Send confirmation email
      await sendOrderConfirmationEmail({
        to: order.customer_email,
        customerName: order.customer_name,
        orderNumber: order.order_number,
        productTitle: order.product_title,
        amount: order.amount,
        downloadToken: order.product.type === 'digital' ? token : undefined,
      })

      console.log('Payment completed:', order.order_number)
    } else if (tradeStatus === 'FAILED') {
      await supabase
        .from('orders')
        .update({ payment_status: 'failed' })
        .eq('id', order.id)

      console.log('Payment failed:', order.order_number)
    }

    return new Response('Webhook processed', { status: 200 })
  } catch (error) {
    console.error('Webhook processing error:', error)
    return new Response('Internal error', { status: 500 })
  }
}
```

---

## 5. Security Best Practices

### 5.1 Signature Verification

**Always verify webhook signatures:**
```typescript
// Critical: Never process webhooks without verification
if (!verifySignature(payload, signature)) {
  return new Response('Unauthorized', { status: 401 })
}
```

### 5.2 Idempotency

**Prevent duplicate processing:**
```typescript
// Check if already processed
if (order.payment_status === 'completed') {
  return new Response('Already processed', { status: 200 })
}

// Use database transactions for atomic updates
await supabase.rpc('process_payment_atomic', {
  order_id: order.id,
  transaction_id: transactionId
})
```

### 5.3 Rate Limiting

**Protect webhook endpoint:**
```typescript
import { Ratelimit } from '@upstash/ratelimit'

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(100, '1 m'), // 100 webhooks per minute
})

const { success } = await ratelimit.limit('telebirr-webhook')
if (!success) {
  return new Response('Rate limit exceeded', { status: 429 })
}
```

### 5.4 Logging

**Log all payment events:**
```typescript
// Log to Supabase or external service
await supabase.from('payment_logs').insert({
  order_id: order.id,
  event_type: 'webhook_received',
  provider: 'telebirr',
  transaction_id: transactionId,
  status: tradeStatus,
  raw_payload: payload,
  created_at: new Date().toISOString(),
})
```

---

## 6. Error Handling

### 6.1 Common Error Codes

| Code | Meaning | Action |
|------|---------|--------|
| 1001 | Invalid signature | Check App Key, regenerate signature |
| 1002 | Insufficient balance | Customer needs to top up |
| 1003 | Transaction timeout | Retry payment |
| 1004 | Invalid phone number | Validate Ethiopian format (+251...) |
| 1005 | Merchant suspended | Contact Telebirr support |
| 2001 | Network error | Retry with exponential backoff |

### 6.2 Retry Strategy

```typescript
async function initiatePaymentWithRetry(params, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await telebirrClient.initiatePayment(params)
      if (result.success) return result
      
      // Don't retry on client errors
      if (result.error?.includes('Invalid')) {
        return result
      }
      
      // Exponential backoff
      if (attempt < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)))
      }
    } catch (error) {
      if (attempt === maxRetries) throw error
    }
  }
}
```

---

## 7. Testing

### 7.1 Sandbox Environment

**Test Credentials:**
```
API URL: https://sandbox.telebirr.et/v2
App ID: test_app_12345
App Key: test_key_abcdef
Merchant Code: TEST_MERCHANT
```

**Test Phone Numbers:**
```
Success: +251911000001  (auto-approves payment)
Failure: +251911000002  (auto-rejects payment)
Timeout: +251911000003  (simulates timeout)
```

### 7.2 Test Scenarios

**1. Successful Payment:**
```bash
curl -X POST https://localhost:3000/api/payments/initiate \
  -H "Content-Type: application/json" \
  -d '{
    "productId": "prod_123",
    "customerEmail": "test@example.com",
    "customerName": "Test User",
    "customerPhone": "+251911000001"
  }'
```

**2. Failed Payment:**
- Use test phone +251911000002
- Verify order status updates to "failed"
- Check error handling in UI

**3. Webhook Testing:**
```bash
# Simulate webhook
curl -X POST https://localhost:3000/api/webhooks/telebirr \
  -H "Content-Type: application/json" \
  -H "x-telebirr-signature: xxx" \
  -d '{
    "outTradeNo": "FAB-20250119-0001",
    "tradeStatus": "SUCCESS",
    "transactionId": "TBR_TEST_123",
    "amount": "299.99",
    "paidAt": "2025-01-19T10:00:00Z"
  }'
```

---

## 8. Monitoring & Alerts

### 8.1 Key Metrics

**Track these metrics:**
- Payment success rate (target: >95%)
- Average payment time (target: <30 seconds)
- Webhook delivery success (target: >99%)
- Refund processing time (target: <24 hours)

### 8.2 Alert Configuration

```typescript
// Alert if payment success rate drops below 90%
if (successRate < 0.90) {
  await sendAlert({
    channel: 'slack',
    message: `âš ï¸ Telebirr success rate: ${successRate * 100}%`,
    severity: 'high'
  })
}

// Alert if webhooks failing
if (webhookFailureRate > 0.05) {
  await sendAlert({
    channel: 'pagerduty',
    message: `ðŸš¨ Telebirr webhook failures: ${webhookFailureRate * 100}%`,
    severity: 'critical'
  })
}
```

---

## 9. Production Checklist

### Pre-Launch

- [ ] Telebirr merchant account approved
- [ ] Production API credentials configured
- [ ] Webhook endpoint HTTPS enabled
- [ ] Signature verification implemented
- [ ] Idempotency checks in place
- [ ] Error handling comprehensive
- [ ] Logging configured (Sentry, database)
- [ ] Rate limiting active
- [ ] Retry logic tested
- [ ] Refund flow tested
- [ ] Customer support process documented

### Post-Launch Monitoring

- [ ] Payment success rate dashboard
- [ ] Webhook delivery monitoring
- [ ] Daily reconciliation reports
- [ ] Weekly financial reports
- [ ] Customer payment issues tracking

---

## 10. Troubleshooting

### Issue: Payments Not Completing

**Diagnosis:**
1. Check webhook logs in Supabase
2. Verify webhook signature
3. Confirm webhook URL is accessible
4. Check for database errors

**Solution:**
```bash
# Test webhook endpoint
curl https://yourdomain.com/api/webhooks/telebirr/health

# Check recent failed webhooks
SELECT * FROM payment_logs 
WHERE event_type = 'webhook_failed' 
ORDER BY created_at DESC 
LIMIT 10;
```

### Issue: High Failure Rate

**Possible Causes:**
- Customer insufficient balance
- Network issues in Ethiopia
- Telebirr system maintenance
- Invalid phone numbers

**Solution:**
- Implement better error messages
- Add retry mechanism
- Provide alternative payment method (Chapa)

---

## 11. Compliance & Regulations

### Ethiopian Payment Regulations

- All transactions must be in ETB
- KYC required for merchants
- Transaction limits may apply (check with Telebirr)
- Tax reporting requirements (withholding tax)

### Data Protection

- Store minimal customer payment data
- Never store full phone numbers unencrypted
- Delete transaction logs after 7 years (compliance)
- GDPR-like principles for Ethiopian users

---

## Document Status

**Version:** 1.0  
**Last Updated:** November 19, 2025  
**Next Review:** After first 1,000 transactions  
**Status:** âœ… Ready for Implementation  

**Maintainer:** Fabrica Engineering Team  
**Support Contact:** Telebirr Business Support: business@telebirr.et