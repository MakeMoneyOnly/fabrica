# Fabrica - Security & Compliance Guide

**Version:** 1.0  
**Last Updated:** November 19, 2025  
**Security Level:** PCI DSS Level 4 Compliant  
**Classification:** Internal Use

---

## 1. Security Overview

### Security Posture

Fabrica implements **defense-in-depth** security with multiple layers:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Layer 7: User Education         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Layer 6: Application Security   ‚îÇ
‚îÇ     (Input validation, XSS, CSRF)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Layer 5: Authentication & Auth  ‚îÇ
‚îÇ     (Clerk JWT, RLS policies)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Layer 4: API Security           ‚îÇ
‚îÇ     (Rate limiting, signatures)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Layer 3: Network Security       ‚îÇ
‚îÇ     (HTTPS, WAF, DDoS protection)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Layer 2: Infrastructure         ‚îÇ
‚îÇ     (Vercel, Supabase hardening)    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Layer 1: Physical Security      ‚îÇ
‚îÇ     (Cloud provider data centers)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Threat Model

**Assets to Protect:**

1. User credentials (passwords, JWT tokens)
2. Customer payment information (Payment accounts - Telebirr supported via Chapa)
3. Creator financial data (revenue, payouts)
4. Digital product files
5. Personal information (emails, phone numbers)

**Threat Actors:**

1. **External Attackers:** Attempting data breaches, payment fraud
2. **Malicious Users:** Fraudulent creators, stolen credit cards
3. **Insiders:** (Future employees with system access)
4. **Automated Bots:** Scraping, DDoS, spam

**Attack Vectors:**

1. SQL Injection ‚Üí **Mitigated by Supabase parameterized queries**
2. XSS ‚Üí **Mitigated by React auto-escaping**
3. CSRF ‚Üí **Mitigated by SameSite cookies + Next.js**
4. Payment fraud ‚Üí **Mitigated by Chapa signature verification**
5. DDoS ‚Üí **Mitigated by Cloudflare**
6. Credential stuffing ‚Üí **Mitigated by Clerk MFA (Phase 2)**

---

## 2. Authentication & Authorization

### 2.1 Clerk Authentication

**Implementation:**

```typescript
// middleware.ts
import { authMiddleware } from '@clerk/nextjs'

export default authMiddleware({
  publicRoutes: [
    '/',
    '/pricing',
    '/:username', // Public storefronts
    '/api/webhooks/(.*)',
  ],
  ignoredRoutes: ['/api/public/(.*)'],
})

export const config = {
  matcher: ['/((?!.+\\.[\\w]+$|_next).*)', '/', '/(api|trpc)(.*)'],
}
```

**Security Features:**

- ‚úÖ Secure JWT tokens (RS256 algorithm)
- ‚úÖ HTTP-only cookies for session tokens
- ‚úÖ Automatic token rotation
- ‚úÖ Session expiry (7 days)
- ‚úÖ IP-based anomaly detection
- üîú Multi-factor authentication (MFA) - Phase 2

### 2.2 Row Level Security (RLS)

**Supabase RLS Policies:**

```sql
-- Users can only view/edit their own data
CREATE POLICY "Users can manage own data"
  ON users
  FOR ALL
  USING (clerk_user_id = auth.jwt() ->> 'sub')
  WITH CHECK (clerk_user_id = auth.jwt() ->> 'sub');

-- Creators can only access their own orders
CREATE POLICY "Creators view own orders"
  ON orders
  FOR SELECT
  USING (
    creator_id = (
      SELECT id FROM users
      WHERE clerk_user_id = auth.jwt() ->> 'sub'
    )
  );

-- Download links accessible only via signed URL API
CREATE POLICY "No direct download access"
  ON download_links
  FOR SELECT
  USING (false); -- API handles access control
```

**Benefits:**

- Database-enforced authorization (can't be bypassed)
- Protection even if application code has bugs
- Audit trail at database level

### 2.3 API Authentication

**Every protected endpoint:**

```typescript
import { auth } from '@clerk/nextjs'

export async function GET(req: Request) {
  const { userId } = auth()

  if (!userId) {
    return new Response('Unauthorized', {
      status: 401,
      headers: {
        'WWW-Authenticate': 'Bearer realm="Fabrica API"',
      },
    })
  }

  // Proceed with authenticated logic
}
```

**Token Validation:**

- Clerk automatically validates JWT signature
- Checks expiration timestamp
- Verifies issuer (iss claim)
- Confirms audience (aud claim)

---

## 3. Payment Security

### 3.1 PCI DSS Compliance

**Fabrica Strategy:** **PCI DSS SAQ A** (Service Provider Level 4)

**Why SAQ A:**

- We never handle raw card data
- Payment processing delegated to Chapa (PCI Level 1 certified, supports Telebirr)
- We only store: order ID, amount, transaction status

**Compliance Checklist:**

- [x] HTTPS for all payment pages
- [x] No cardholder data stored in database
- [x] Payment account numbers encrypted at rest (Telebirr accounts supported)
- [x] Payment logs do not contain sensitive data
- [x] Webhook signature verification
- [x] Secure key storage (environment variables)
- [x] Annual security audit (self-assessment)

### 3.2 Webhook Security

**Critical: Signature Verification**

```typescript
// app/api/webhooks/chapa/route.ts
import crypto from 'crypto'

export async function POST(req: Request) {
  const signature = req.headers.get('Chapa-Signature')
  const payload = await req.text()

  // CRITICAL: Verify signature FIRST
  const expectedSignature = crypto
    .createHmac('sha256', process.env.CHAPA_WEBHOOK_SECRET!)
    .update(payload)
    .digest('hex')
    .toUpperCase()

  // Constant-time comparison (prevent timing attacks)
  if (!crypto.timingSafeEqual(Buffer.from(signature || ''), Buffer.from(expectedSignature))) {
    console.error('Invalid webhook signature')
    return new Response('Unauthorized', { status: 401 })
  }

  // Safe to process webhook
  const data = JSON.parse(payload)
  await processPayment(data)

  return new Response('OK', { status: 200 })
}
```

**Why This Matters:**

- Without signature verification, anyone could send fake "payment completed" webhooks
- Would result in free products for attackers
- Financial loss for creators

### 3.3 Idempotency

**Prevent Duplicate Processing:**

```typescript
// Check if already processed
const { data: existingOrder } = await supabase
  .from('orders')
  .select('payment_status')
  .eq('id', orderId)
  .single()

if (existingOrder.payment_status === 'completed') {
  console.log('Payment already processed, skipping')
  return new Response('Already processed', { status: 200 })
}

// Use database transaction for atomic update
await supabase.rpc('process_payment_atomic', {
  order_id: orderId,
  transaction_id: chapaTransactionId,
})
```

**SQL Function (Atomic):**

```sql
CREATE OR REPLACE FUNCTION process_payment_atomic(
  order_id UUID,
  transaction_id TEXT
)
RETURNS VOID AS $$
BEGIN
  UPDATE orders
  SET
    payment_status = 'completed',
    payment_provider_id = transaction_id,
    paid_at = NOW(),
    updated_at = NOW()
  WHERE id = order_id
    AND payment_status != 'completed'; -- Only update if not already completed
END;
$$ LANGUAGE plpgsql;
```

---

## 4. Data Protection

### 4.1 Encryption

**Data at Rest:**

- ‚úÖ Database: AES-256 encryption (Supabase default)
- ‚úÖ File storage: AES-256 encryption (Supabase Storage)
- ‚úÖ Backups: Encrypted with separate keys
- ‚úÖ Environment variables: Encrypted by Vercel

**Data in Transit:**

- ‚úÖ TLS 1.3 for all connections
- ‚úÖ HTTPS enforced (Vercel + Cloudflare)
- ‚úÖ HSTS headers enabled
- ‚úÖ Certificate pinning (Phase 2)

**Sensitive Data Encryption:**

```typescript
// Encrypt payment account numbers (Telebirr supported)
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex')

export function encryptPaymentAccount(accountNumber: string): string {
  const iv = randomBytes(16)
  const cipher = createCipheriv(ALGORITHM, KEY, iv)

  let encrypted = cipher.update(accountNumber, 'utf8', 'hex')
  encrypted += cipher.final('hex')

  const authTag = cipher.getAuthTag()

  // Format: iv:authTag:encrypted
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
}

export function decryptPaymentAccount(encrypted: string): string {
  const [ivHex, authTagHex, encryptedData] = encrypted.split(':')

  const iv = Buffer.from(ivHex, 'hex')
  const authTag = Buffer.from(authTagHex, 'hex')
  const decipher = createDecipheriv(ALGORITHM, KEY, iv)

  decipher.setAuthTag(authTag)

  let decrypted = decipher.update(encryptedData, 'hex', 'utf8')
  decrypted += decipher.final('utf8')

  return decrypted
}
```

### 4.2 Personal Data Handling

**Data Classification:**

| Data Type        | Classification | Storage      | Retention                  |
| ---------------- | -------------- | ------------ | -------------------------- |
| Email addresses  | PII            | Encrypted    | Account lifetime + 7 years |
| Phone numbers    | PII            | Encrypted    | Account lifetime + 7 years |
| Payment info     | Sensitive      | Never stored | N/A                        |
| Product files    | Creator IP     | Encrypted    | Until deleted by creator   |
| Order history    | Financial      | Encrypted    | 7 years (tax compliance)   |
| Analytics events | Non-sensitive  | Plaintext    | 90 days                    |

**Data Minimization:**

- Only collect data necessary for service
- No tracking of user browsing behavior outside Fabrica
- No sharing data with third parties (except payment processors)

### 4.3 GDPR-Like Privacy Principles

**Ethiopian Context:**
Ethiopia doesn't have comprehensive data protection law yet (as of 2025), but we implement GDPR-like principles proactively:

**1. Lawfulness, Fairness, Transparency**

- Clear privacy policy
- Explicit consent for email marketing
- Transparent data usage

**2. Purpose Limitation**

- Data used only for stated purposes
- No repurposing without consent

**3. Data Minimization**

- Collect only necessary information
- No unnecessary tracking

**4. Accuracy**

- Users can update their information
- Regular data quality checks

**5. Storage Limitation**

- Retention periods defined
- Automated deletion after retention period

**6. Integrity & Confidentiality**

- Encryption at rest and in transit
- Access controls
- Regular security audits

**User Rights Implementation:**

```typescript
// app/api/users/me/export/route.ts
export async function GET(req: Request) {
  const { userId } = auth()

  // Export ALL user data (GDPR Article 15)
  const userData = {
    profile: await getUserProfile(userId),
    products: await getUserProducts(userId),
    orders: await getUserOrders(userId),
    analytics: await getUserAnalytics(userId),
    referrals: await getUserReferrals(userId),
  }

  return new Response(JSON.stringify(userData, null, 2), {
    headers: {
      'Content-Type': 'application/json',
      'Content-Disposition': 'attachment; filename="fabrica-data.json"',
    },
  })
}

// app/api/users/me/delete/route.ts
export async function DELETE(req: Request) {
  const { userId } = auth()

  // Right to deletion (GDPR Article 17)
  // 1. Anonymize orders (keep for accounting)
  await anonymizeUserOrders(userId)

  // 2. Delete personal data
  await deleteUserAccount(userId)

  // 3. Remove from Clerk
  await clerkClient.users.deleteUser(userId)

  return new Response('Account deleted', { status: 200 })
}
```

---

## 5. Application Security

### 5.1 Input Validation

**Always Validate with Zod:**

```typescript
import * as z from 'zod'

const productSchema = z.object({
  title: z.string().min(3).max(100),
  description: z.string().max(1000).optional(),
  price: z.number().min(10).max(100000),
  type: z.enum(['digital', 'booking', 'link']),
  fileSize: z
    .number()
    .max(500 * 1024 * 1024)
    .optional(), // 500MB max
})

export async function POST(req: Request) {
  const body = await req.json()

  // Validate input
  const validation = productSchema.safeParse(body)

  if (!validation.success) {
    return new Response(
      JSON.stringify({
        success: false,
        error: {
          code: 'VALIDATION_ERROR',
          message: 'Invalid input',
          details: validation.error.flatten(),
        },
      }),
      { status: 400 }
    )
  }

  const data = validation.data
  // Safe to use validated data
}
```

**Phone Number Validation:**

```typescript
const ethiopianPhoneSchema = z
  .string()
  .refine((phone) => /^(\+251|0)?9\d{8}$/.test(phone.replace(/\s/g, '')), {
    message: 'Invalid Ethiopian phone number format',
  })
```

### 5.2 XSS Prevention

**React Automatic Escaping:**

```typescript
// ‚úÖ SAFE: React escapes by default
<div>{userInput}</div>

// ‚ùå DANGEROUS: Don't use dangerouslySetInnerHTML without sanitization
<div dangerouslySetInnerHTML={{ __html: userInput }} />

// ‚úÖ SAFE: Use DOMPurify if you must render HTML
import DOMPurify from 'isomorphic-dompurify'

<div dangerouslySetInnerHTML={{
  __html: DOMPurify.sanitize(userGeneratedHTML)
}} />
```

**Content Security Policy (CSP):**

```typescript
// next.config.js
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: `
      default-src 'self';
      script-src 'self' 'unsafe-eval' 'unsafe-inline' *.clerk.com *.posthog.com;
      style-src 'self' 'unsafe-inline';
      img-src 'self' data: blob: https:;
      font-src 'self' data:;
      connect-src 'self' *.supabase.co *.clerk.com *.posthog.com;
      frame-src 'self' *.clerk.com *.chapa.co;
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
    `
      .replace(/\s{2,}/g, ' ')
      .trim(),
  },
]
```

### 5.3 CSRF Protection

**Next.js Built-in Protection:**

- SameSite cookies (Lax/Strict)
- POST requests require proper origin
- Automatic CSRF token handling

**Additional Headers:**

```typescript
// next.config.js
{
  key: 'X-Frame-Options',
  value: 'SAMEORIGIN'
},
{
  key: 'X-Content-Type-Options',
  value: 'nosniff'
},
{
  key: 'Referrer-Policy',
  value: 'strict-origin-when-cross-origin'
}
```

### 5.4 SQL Injection Prevention

**Supabase Parameterized Queries:**

```typescript
// ‚úÖ SAFE: Parameterized query
const { data } = await supabase
  .from('products')
  .select('*')
  .eq('creator_id', userId)
  .ilike('title', `%${searchTerm}%`) // Supabase handles escaping

// ‚ùå NEVER DO THIS: Raw SQL with user input
const { data } = await supabase.rpc('unsafe_query', {
  sql: `SELECT * FROM products WHERE title = '${userInput}'`,
})
```

---

## 6. Rate Limiting & DDoS Protection

### 6.1 Upstash Redis Rate Limiting

```typescript
// lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

export const rateLimiters = {
  // API requests: 100/minute per user
  api: new Ratelimit({
    redis: Redis.fromEnv(),
    limiter: Ratelimit.slidingWindow(100, '1 m'),
    analytics: true,
    prefix: 'rl:api',
  }),

  // Payment initiation: 10/hour per user
  payment: new Ratelimit({
    redis: Redis.fromEnv(),
    limiter: Ratelimit.slidingWindow(10, '1 h'),
    analytics: true,
    prefix: 'rl:payment',
  }),

  // Webhook: 1000/minute per source
  webhook: new Ratelimit({
    redis: Redis.fromEnv(),
    limiter: Ratelimit.slidingWindow(1000, '1 m'),
    analytics: true,
    prefix: 'rl:webhook',
  }),
}

// Usage in API route
export async function POST(req: Request) {
  const { userId } = auth()
  const identifier = userId || req.headers.get('x-forwarded-for') || 'anonymous'

  const { success, limit, remaining, reset } = await rateLimiters.payment.limit(identifier)

  if (!success) {
    return new Response('Rate limit exceeded', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': reset.toString(),
      },
    })
  }

  // Process request
}
```

### 6.2 Cloudflare DDoS Protection

**Enabled Features:**

- ‚úÖ Automatic DDoS mitigation (L3/L4)
- ‚úÖ Bot Fight Mode (blocks known bad bots)
- ‚úÖ Challenge pages for suspicious traffic
- ‚úÖ Rate limiting at edge
- ‚úÖ Geographic blocking (if needed)

**WAF Rules (Pro Plan):**

```
// Block suspicious user agents
(http.user_agent contains "curl" and not cf.verified_bot_category)

// Block countries with high fraud (if applicable)
(ip.geoip.country in {"CN" "RU" "UA"} and not http.request.uri.path startswith "/api/webhooks/")

// Allow only specific methods
(http.request.method not in {"GET" "POST" "PUT" "PATCH" "DELETE" "OPTIONS"})
```

---

## 7. Logging & Monitoring

### 7.1 Security Event Logging

**What to Log:**

```typescript
// lib/security-logger.ts
import * as Sentry from '@sentry/nextjs'

export function logSecurityEvent(event: {
  type: 'auth_failure' | 'payment_fraud' | 'rate_limit' | 'suspicious_activity'
  userId?: string
  ipAddress?: string
  details: Record<string, any>
}) {
  // Log to Sentry
  Sentry.captureMessage(`Security Event: ${event.type}`, {
    level: 'warning',
    extra: event,
  })

  // Log to Supabase
  await supabase.from('security_logs').insert({
    event_type: event.type,
    user_id: event.userId,
    ip_address: event.ipAddress,
    details: event.details,
    created_at: new Date().toISOString(),
  })
}

// Usage
if (failedLoginAttempts > 5) {
  await logSecurityEvent({
    type: 'auth_failure',
    userId: attemptedUserId,
    ipAddress: req.headers.get('x-forwarded-for'),
    details: { attempts: failedLoginAttempts },
  })
}
```

**Sensitive Data Redaction:**

```typescript
// NEVER log these
const SENSITIVE_FIELDS = ['password', 'token', 'apiKey', 'paymentAccount', 'phoneNumber', 'email']

function redactSensitiveData(obj: any): any {
  if (typeof obj !== 'object') return obj

  const redacted = { ...obj }

  for (const key of Object.keys(redacted)) {
    if (SENSITIVE_FIELDS.includes(key)) {
      redacted[key] = '[REDACTED]'
    } else if (typeof redacted[key] === 'object') {
      redacted[key] = redactSensitiveData(redacted[key])
    }
  }

  return redacted
}
```

### 7.2 Alerting

**Sentry Integration:**

```typescript
// sentry.server.config.ts
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 0.1,

  beforeSend(event, hint) {
    // Alert on critical errors
    if (event.level === 'fatal' || event.level === 'error') {
      // Send to Slack/PagerDuty
      notifyTeam({
        severity: event.level,
        message: event.message,
        url: event.request?.url,
      })
    }

    return event
  },
})
```

**Critical Alerts:**

- Payment success rate < 90%
- Webhook delivery failure > 5%
- Database CPU > 90%
- Error rate > 5%
- Unusual traffic spike (10x normal)

---

## 8. Incident Response

### 8.1 Incident Response Plan

**Severity Levels:**

| Level             | Definition           | Response Time | Examples                                    |
| ----------------- | -------------------- | ------------- | ------------------------------------------- |
| **P0 - Critical** | Service down         | <15 min       | Database offline, payment processing broken |
| **P1 - High**     | Major feature broken | <1 hour       | Dashboard not loading, webhooks failing     |
| **P2 - Medium**   | Minor feature broken | <4 hours      | Analytics not updating, email delays        |
| **P3 - Low**      | Cosmetic issue       | <24 hours     | UI glitch, typo                             |

**Response Steps:**

1. **Detect** (monitoring alerts or user report)
2. **Triage** (assess severity, assign P-level)
3. **Communicate** (status page, social media)
4. **Investigate** (logs, metrics, recent deploys)
5. **Mitigate** (rollback, hotfix, workaround)
6. **Resolve** (deploy fix, verify)
7. **Post-mortem** (root cause analysis, prevention)

### 8.2 Security Incident Response

**If Payment Fraud Detected:**

1. Immediately suspend affected orders
2. Contact Chapa fraud team
3. Notify affected creators
4. Review similar transactions
5. Implement additional fraud checks
6. Document and report to authorities if needed

**If Data Breach Suspected:**

1. Isolate affected systems
2. Preserve evidence (logs, database snapshots)
3. Assess scope (what data, how many users)
4. Notify users if PII compromised (within 72 hours)
5. Engage security firm for forensics
6. Report to Ethiopian authorities (if law requires)
7. Implement fixes to prevent recurrence

**If DDoS Attack:**

1. Enable Cloudflare "I'm Under Attack" mode
2. Increase rate limits temporarily
3. Block malicious IPs/countries
4. Scale infrastructure if needed
5. Monitor for data exfiltration attempts

---

## 9. Compliance Checklist

### Pre-Launch Security Audit

- [ ] All API endpoints have authentication
- [ ] Rate limiting configured on all routes
- [ ] Webhook signature verification implemented
- [ ] SQL injection prevention verified (parameterized queries)
- [ ] XSS prevention verified (React escaping + CSP)
- [ ] CSRF protection enabled
- [ ] HTTPS enforced (no HTTP allowed)
- [ ] Environment variables not committed to Git
- [ ] Sensitive data encrypted at rest
- [ ] Password not stored (Clerk handles auth)
- [ ] File upload size limits enforced
- [ ] Error messages don't leak sensitive info
- [ ] Logging excludes sensitive data
- [ ] Database backups automated
- [ ] RLS policies enabled on all tables
- [ ] Penetration testing completed
- [ ] Privacy policy published
- [ ] Terms of service published
- [ ] Cookie consent implemented

### Quarterly Security Reviews

- [ ] Rotate encryption keys
- [ ] Review and update dependencies (`npm audit`)
- [ ] Review access logs for anomalies
- [ ] Test disaster recovery procedures
- [ ] Review and update security policies
- [ ] Conduct team security training

---

## 10. Security Best Practices for Team

### For Developers

**DO:**

- ‚úÖ Always validate user input with Zod
- ‚úÖ Use parameterized queries (Supabase handles this)
- ‚úÖ Verify webhook signatures
- ‚úÖ Log security events
- ‚úÖ Use environment variables for secrets
- ‚úÖ Enable MFA on all accounts (GitHub, Vercel, Supabase)

**DON'T:**

- ‚ùå Commit secrets to Git
- ‚ùå Log sensitive data (passwords, tokens, PII)
- ‚ùå Trust user input without validation
- ‚ùå Use `dangerouslySetInnerHTML` without sanitization
- ‚ùå Disable security features "temporarily"
- ‚ùå Skip security reviews in PRs

### For Operations

- Monitor security alerts daily
- Keep all dependencies up-to-date
- Run weekly `npm audit` checks
- Review Sentry errors regularly
- Test backups monthly

---

## Document Status

**Version:** 1.0  
**Last Updated:** November 19, 2025  
**Next Security Audit:** February 19, 2026  
**Status:** ‚úÖ Complete  
**Classification:** Internal Use  
**Maintainer:** Fabrica Security Team
